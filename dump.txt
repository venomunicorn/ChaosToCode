--- FILE: settings.gradle.kts ---

kotlin
pluginManagement {
    repositories {
        google()
        mavenCentral()
        gradlePluginPortal()
    }
}
dependencyResolutionManagement {
    repositoriesMode.set(RepositoriesMode.FAIL_ON_PROJECT_REPOS)
    repositories {
        google()
        mavenCentral()
        maven { url = uri("https://jitpack.io") }
    }
}

rootProject.name = "Kharcha"
include(":app")
--- FILE: build.gradle.kts ---

kotlin
plugins {
    id("com.android.application") version "8.2.1" apply false
    id("org.jetbrains.kotlin.android") version "1.9.22" apply false
    id("com.google.dagger.hilt.android") version "2.51" apply false
    id("com.google.devtools.ksp") version "1.9.22-1.0.17" apply false
}
--- FILE: gradle.properties ---

text
org.gradle.jvmargs=-Xmx2048m -Dfile.encoding=UTF-8
android.useAndroidX=true
android.nonTransitiveRClass=true
kotlin.code.style=official
--- FILE: secrets.template ---

text
# ML Kit and Cloud Vision credentials (optional, mock fallback provided)
MLKIT_API_KEY=your_mlkit_api_key_here

# Place this file as local.properties with actual keys for production
# The app will use mock/sample data if keys are not present
--- FILE: app/build.gradle.kts ---

kotlin
plugins {
    id("com.android.application")
    id("org.jetbrains.kotlin.android")
    id("com.google.dagger.hilt.android")
    id("com.google.devtools.ksp")
    kotlin("plugin.serialization") version "1.9.22"
}

android {
    namespace = "com.kharcha.app"
    compileSdk = 34

    defaultConfig {
        applicationId = "com.kharcha.app"
        minSdk = 24
        targetSdk = 34
        versionCode = 1
        versionName = "1.0"

        testInstrumentationRunner = "androidx.test.runner.AndroidJUnitRunner"
        vectorDrawables {
            useSupportLibrary = true
        }
    }

    buildTypes {
        release {
            isMinifyEnabled = false
            proguardFiles(
                getDefaultProguardFile("proguard-android-optimize.txt"),
                "proguard-rules.pro"
            )
        }
    }
    
    compileOptions {
        isCoreLibraryDesugaringEnabled = true
        sourceCompatibility = JavaVersion.VERSION_17
        targetCompatibility = JavaVersion.VERSION_17
    }
    
    kotlinOptions {
        jvmTarget = "17"
    }
    
    buildFeatures {
        compose = true
    }
    
    composeOptions {
        kotlinCompilerExtensionVersion = "1.5.8"
    }
    
    packaging {
        resources {
            excludes += "/META-INF/{AL2.0,LGPL2.1}"
            excludes += "META-INF/DEPENDENCIES"
        }
    }
    
    ksp {
        arg("room.schemaLocation", "$projectDir/schemas")
    }
}

dependencies {
    // Core Android
    implementation("androidx.core:core-ktx:1.12.0")
    implementation("androidx.lifecycle:lifecycle-runtime-ktx:2.7.0")
    implementation("androidx.activity:activity-compose:1.8.2")
    
    // Compose
    implementation(platform("androidx.compose:compose-bom:2024.02.01"))
    implementation("androidx.compose.ui:ui")
    implementation("androidx.compose.ui:ui-graphics")
    implementation("androidx.compose.ui:ui-tooling-preview")
    implementation("androidx.compose.material3:material3:1.2.0")
    implementation("androidx.compose.material:material-icons-extended")
    
    // Navigation
    implementation("androidx.navigation:navigation-compose:2.7.7")
    implementation("androidx.hilt:hilt-navigation-compose:1.2.0")
    
    // Room
    implementation("androidx.room:room-runtime:2.6.1")
    implementation("androidx.room:room-ktx:2.6.1")
    ksp("androidx.room:room-compiler:2.6.1")
    
    // Hilt
    implementation("com.google.dagger:hilt-android:2.51")
    ksp("com.google.dagger:hilt-compiler:2.51")
    
    // DataStore
    implementation("androidx.datastore:datastore-preferences:1.0.0")
    
    // Security - Encrypted storage
    implementation("androidx.security:security-crypto:1.1.0-alpha06")
    
    // Biometric
    implementation("androidx.biometric:biometric:1.1.0")
    
    // WorkManager for background tasks
    implementation("androidx.work:work-runtime-ktx:2.9.0")
    
    // CameraX for receipt scanning
    implementation("androidx.camera:camera-core:1.3.1")
    implementation("androidx.camera:camera-camera2:1.3.1")
    implementation("androidx.camera:camera-lifecycle:1.3.1")
    implementation("androidx.camera:camera-view:1.3.1")
    
    // ML Kit Text Recognition
    implementation("com.google.mlkit:text-recognition:16.0.0")
    
    // TensorFlow Lite (interface for ML models)
    implementation("org.tensorflow:tensorflow-lite:2.14.0")
    implementation("org.tensorflow:tensorflow-lite-support:0.4.4")
    
    // Charts - Vico for Compose
    implementation("com.patrykandpatrick.vico:compose:1.13.1")
    implementation("com.patrykandpatrick.vico:compose-m3:1.13.1")
    implementation("com.patrykandpatrick.vico:core:1.13.1")
    
    // CSV Parser
    implementation("com.opencsv:opencsv:5.7.1")
    
    // Excel Parser - Apache POI
    implementation("org.apache.poi:poi:5.2.3")
    implementation("org.apache.poi:poi-ooxml:5.2.3")
    
    // Kotlinx Serialization for JSON
    implementation("org.jetbrains.kotlinx:kotlinx-serialization-json:1.6.2")
    
    // Java 8+ time API desugaring
    coreLibraryDesugaring("com.android.tools:desugar_jdk_libs:2.0.4")
    
    // Testing
    testImplementation("junit:junit:4.13.2")
    testImplementation("androidx.room:room-testing:2.6.1")
    testImplementation("org.jetbrains.kotlinx:kotlinx-coroutines-test:1.7.3")
    testImplementation("androidx.arch.core:core-testing:2.2.0")
    testImplementation("io.mockk:mockk:1.13.9")
    androidTestImplementation("androidx.test.ext:junit:1.1.5")
    androidTestImplementation("androidx.test.espresso:espresso-core:3.5.1")
    androidTestImplementation(platform("androidx.compose:compose-bom:2024.02.01"))
    androidTestImplementation("androidx.compose.ui:ui-test-junit4")
    debugImplementation("androidx.compose.ui:ui-tooling")
    debugImplementation("androidx.compose.ui:ui-test-manifest")
}
--- FILE: app/proguard-rules.pro ---

text
# Add project specific ProGuard rules here.
-keepattributes SourceFile,LineNumberTable
-renamesourcefileattribute SourceFile

# Keep Room classes
-keep class * extends androidx.room.RoomDatabase
-keep @androidx.room.Entity class *
-dontwarn androidx.room.paging.**

# Keep Apache POI classes
-dontwarn org.apache.poi.**
-dontwarn org.apache.xmlbeans.**
-dontwarn org.openxmlformats.schemas.**
--- FILE: app/src/main/AndroidManifest.xml ---

xml
<?xml version="1.0" encoding="utf-8"?>
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools">

    <uses-feature android:name="android.hardware.camera" android:required="false" />
    <uses-permission android:name="android.permission.CAMERA" />
    <uses-permission android:name="android.permission.READ_SMS" />
    <uses-permission android:name="android.permission.RECEIVE_SMS" />
    <uses-permission android:name="android.permission.USE_BIOMETRIC" />

    <application
        android:name=".KharchaApp"
        android:allowBackup="true"
        android:dataExtractionRules="@xml/data_extraction_rules"
        android:fullBackupContent="@xml/backup_rules"
        android:icon="@mipmap/ic_launcher"
        android:label="@string/app_name"
        android:roundIcon="@mipmap/ic_launcher_round"
        android:supportsRtl="true"
        android:theme="@style/Theme.Kharcha"
        tools:targetApi="31">
        
        <activity
            android:name=".MainActivity"
            android:exported="true"
            android:theme="@style/Theme.Kharcha">
            <intent-filter>
                <action android:name="android.intent.action.MAIN" />
                <category android:name="android.intent.category.LAUNCHER" />
            </intent-filter>
        </activity>

        <receiver
            android:name=".sms.SmsReceiver"
            android:enabled="true"
            android:exported="true"
            android:permission="android.permission.BROADCAST_SMS">
            <intent-filter android:priority="999">
                <action android:name="android.provider.Telephony.SMS_RECEIVED" />
            </intent-filter>
        </receiver>

    </application>

</manifest>
--- FILE: app/src/main/res/values/strings.xml ---

xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="app_name">Kharcha</string>
</resources>
--- FILE: app/src/main/res/values/themes.xml ---

xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <style name="Theme.Kharcha" parent="android:Theme.Material.Light.NoActionBar" />
</resources>
--- FILE: app/src/main/res/xml/backup_rules.xml ---

xml
<?xml version="1.0" encoding="utf-8"?>
<full-backup-content>
    <exclude domain="sharedpref" path="device.xml"/>
</full-backup-content>
--- FILE: app/src/main/res/xml/data_extraction_rules.xml ---

xml
<?xml version="1.0" encoding="utf-8"?>
<data-extraction-rules>
    <cloud-backup>
        <include domain="database" path="kharcha_database.db" />
    </cloud-backup>
</data-extraction-rules>
--- FILE: app/src/main/java/com/kharcha/app/KharchaApp.kt ---

kotlin
package com.kharcha.app

import android.app.Application
import androidx.work.Configuration
import androidx.work.ExistingPeriodicWorkPolicy
import androidx.work.PeriodicWorkRequestBuilder
import androidx.work.WorkManager
import com.kharcha.app.worker.RecurringTransactionWorker
import dagger.hilt.android.HiltAndroidApp
import java.util.concurrent.TimeUnit

@HiltAndroidApp
class KharchaApp : Application(), Configuration.Provider {
    
    override fun onCreate() {
        super.onCreate()
        scheduleRecurringWork()
    }

    override fun getWorkManagerConfiguration(): Configuration {
        return Configuration.Builder()
            .setMinimumLoggingLevel(android.util.Log.INFO)
            .build()
    }

    private fun scheduleRecurringWork() {
        val workRequest = PeriodicWorkRequestBuilder<RecurringTransactionWorker>(
            1, TimeUnit.DAYS
        ).build()

        WorkManager.getInstance(this).enqueueUniquePeriodicWork(
            "recurring_transaction_work",
            ExistingPeriodicWorkPolicy.KEEP,
            workRequest
        )
    }
}
--- FILE: app/src/main/java/com/kharcha/app/MainActivity.kt ---

kotlin
package com.kharcha.app

import android.os.Bundle
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.activity.enableEdgeToEdge
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.Surface
import androidx.compose.ui.Modifier
import com.kharcha.app.navigation.NavGraph
import com.kharcha.app.ui.theme.KharchaTheme
import dagger.hilt.android.AndroidEntryPoint

@AndroidEntryPoint
class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        enableEdgeToEdge()
        
        setContent {
            KharchaTheme {
                Surface(
                    modifier = Modifier.fillMaxSize(),
                    color = MaterialTheme.colorScheme.background
                ) {
                    NavGraph()
                }
            }
        }
    }
}
--- FILE: app/src/main/java/com/kharcha/app/data/db/KharchaDatabase.kt ---

kotlin
package com.kharcha.app.data.db

import androidx.room.Database
import androidx.room.RoomDatabase
import androidx.room.TypeConverters
import com.kharcha.app.data.dao.AccountDao
import com.kharcha.app.data.dao.AttachmentDao
import com.kharcha.app.data.dao.CategoryDao
import com.kharcha.app.data.dao.TransactionDao
import com.kharcha.app.data.model.AccountEntity
import com.kharcha.app.data.model.AttachmentEntity
import com.kharcha.app.data.model.CategoryEntity
import com.kharcha.app.data.model.TransactionEntity

@Database(
    entities = [
        TransactionEntity::class,
        CategoryEntity::class,
        AccountEntity::class,
        AttachmentEntity::class
    ],
    version = 1,
    exportSchema = true
)
@TypeConverters(Converters::class)
abstract class KharchaDatabase : RoomDatabase() {
    abstract fun transactionDao(): TransactionDao
    abstract fun categoryDao(): CategoryDao
    abstract fun accountDao(): AccountDao
    abstract fun attachmentDao(): AttachmentDao
}
--- FILE: app/src/main/java/com/kharcha/app/data/db/Converters.kt ---

kotlin
package com.kharcha.app.data.db

import androidx.room.TypeConverter
import java.time.LocalDate
import java.time.LocalDateTime

class Converters {
    @TypeConverter
    fun fromLocalDateTime(value: LocalDateTime?): String? {
        return value?.toString()
    }

    @TypeConverter
    fun toLocalDateTime(value: String?): LocalDateTime? {
        return value?.let { LocalDateTime.parse(it) }
    }

    @TypeConverter
    fun fromLocalDate(value: LocalDate?): String? {
        return value?.toString()
    }

    @TypeConverter
    fun toLocalDate(value: String?): LocalDate? {
        return value?.let { LocalDate.parse(it) }
    }
}
--- FILE: app/src/main/java/com/kharcha/app/data/db/DatabaseMigrations.kt ---

kotlin
package com.kharcha.app.data.db

import androidx.room.migration.Migration
import androidx.sqlite.db.SupportSQLiteDatabase

object DatabaseMigrations {
    
    val MIGRATION_OLD_TO_1 = object : Migration(0, 1) {
        override fun migrate(db: SupportSQLiteDatabase) {
            // This migration simulates moving from old expenses table to new transactions table
            // If old expenses table exists, migrate data
            val cursor = db.query("SELECT name FROM sqlite_master WHERE type='table' AND name='expenses'")
            val oldTableExists = cursor.moveToFirst()
            cursor.close()
            
            if (oldTableExists) {
                // Create transactions table
                db.execSQL("""
                    CREATE TABLE IF NOT EXISTS transactions (
                        id INTEGER PRIMARY KEY AUTOINCREMENT NOT NULL,
                        type TEXT NOT NULL,
                        amount REAL NOT NULL,
                        currency TEXT NOT NULL,
                        date TEXT NOT NULL,
                        categoryId INTEGER NOT NULL,
                        accountId INTEGER,
                        note TEXT NOT NULL,
                        metadata TEXT NOT NULL,
                        isRecurring INTEGER NOT NULL DEFAULT 0,
                        recurrenceType TEXT,
                        lastProcessedDate TEXT,
                        FOREIGN KEY(categoryId) REFERENCES categories(id) ON DELETE CASCADE,
                        FOREIGN KEY(accountId) REFERENCES accounts(id) ON DELETE SET NULL
                    )
                """.trimIndent())
                
                db.execSQL("CREATE INDEX IF NOT EXISTS index_transactions_date ON transactions(date)")
                db.execSQL("CREATE INDEX IF NOT EXISTS index_transactions_categoryId ON transactions(categoryId)")
                
                // Migrate old expenses to transactions
                db.execSQL("""
                    INSERT INTO transactions (type, amount, currency, date, categoryId, note, metadata, isRecurring, recurrenceType, lastProcessedDate)
                    SELECT 
                        'EXPENSE' as type,
                        amount,
                        COALESCE(currency, 'INR') as currency,
                        datetime(timestamp / 1000, 'unixepoch') as date,
                        COALESCE((SELECT id FROM categories WHERE name = expenses.category LIMIT 1), 1) as categoryId,
                        COALESCE(note, '') as note,
                        '{}' as metadata,
                        isRecurring,
                        recurrenceType,
                        CASE WHEN lastProcessedDate IS NOT NULL THEN datetime(lastProcessedDate / 1000, 'unixepoch') ELSE NULL END as lastProcessedDate
                    FROM expenses
                """.trimIndent())
                
                // Drop old expenses table
                db.execSQL("DROP TABLE IF EXISTS expenses")
            }
        }
    }
}
--- FILE: app/src/main/java/com/kharcha/app/data/model/TransactionEntity.kt ---

kotlin
package com.kharcha.app.data.model

import androidx.room.Entity
import androidx.room.ForeignKey
import androidx.room.Index
import androidx.room.PrimaryKey
import java.time.LocalDate
import java.time.LocalDateTime

@Entity(
    tableName = "transactions",
    foreignKeys = [
        ForeignKey(
            entity = CategoryEntity::class,
            parentColumns = ["id"],
            childColumns = ["categoryId"],
            onDelete = ForeignKey.CASCADE
        ),
        ForeignKey(
            entity = AccountEntity::class,
            parentColumns = ["id"],
            childColumns = ["accountId"],
            onDelete = ForeignKey.SET_NULL
        )
    ],
    indices = [
        Index("date"),
        Index("categoryId"),
        Index("accountId")
    ]
)
data class TransactionEntity(
    @PrimaryKey(autoGenerate = true)
    val id: Long = 0,
    val type: TransactionType,
    val amount: Double,
    val currency: String = "INR",
    val date: LocalDateTime = LocalDateTime.now(),
    val categoryId: Long,
    val accountId: Long? = null,
    val note: String = "",
    val metadata: String = "{}",
    val isRecurring: Boolean = false,
    val recurrenceType: RecurrenceType? = null,
    val lastProcessedDate: LocalDate? = null
)

enum class TransactionType {
    INCOME, EXPENSE, TRANSFER
}

enum class RecurrenceType {
    DAILY, WEEKLY, MONTHLY, YEARLY
}
--- FILE: app/src/main/java/com/kharcha/app/data/model/CategoryEntity.kt ---

kotlin
package com.kharcha.app.data.model

import androidx.room.Entity
import androidx.room.Index
import androidx.room.PrimaryKey

@Entity(
    tableName = "categories",
    indices = [Index(value = ["name", "type"], unique = true)]
)
data class CategoryEntity(
    @PrimaryKey(autoGenerate = true)
    val id: Long = 0,
    val name: String,
    val type: TransactionType,
    val icon: String? = null,
    val color: String? = null,
    val isDefault: Boolean = false
)
--- FILE: app/src/main/java/com/kharcha/app/data/model/AccountEntity.kt ---

kotlin
package com.kharcha.app.data.model

import androidx.room.Entity
import androidx.room.PrimaryKey

@Entity(tableName = "accounts")
data class AccountEntity(
    @PrimaryKey(autoGenerate = true)
    val id: Long = 0,
    val name: String,
    val type: AccountType,
    val balance: Double = 0.0,
    val currency: String = "INR"
)

enum class AccountType {
    CASH, BANK, CREDIT_CARD, WALLET
}
--- FILE: app/src/main/java/com/kharcha/app/data/model/AttachmentEntity.kt ---

kotlin
package com.kharcha.app.data.model

import androidx.room.Entity
import androidx.room.ForeignKey
import androidx.room.Index
import androidx.room.PrimaryKey

@Entity(
    tableName = "attachments",
    foreignKeys = [
        ForeignKey(
            entity = TransactionEntity::class,
            parentColumns = ["id"],
            childColumns = ["transactionId"],
            onDelete = ForeignKey.CASCADE
        )
    ],
    indices = [Index("transactionId")]
)
data class AttachmentEntity(
    @PrimaryKey(autoGenerate = true)
    val id: Long = 0,
    val transactionId: Long,
    val filePath: String,
    val mimeType: String,
    val thumbnailPath: String? = null
)
--- FILE: app/src/main/java/com/kharcha/app/data/dao/TransactionDao.kt ---

kotlin
package com.kharcha.app.data.dao

import androidx.room.*
import com.kharcha.app.data.model.TransactionEntity
import com.kharcha.app.data.model.TransactionType
import kotlinx.coroutines.flow.Flow
import java.time.LocalDateTime

@Dao
interface TransactionDao {
    
    @Insert(onConflict = OnConflictStrategy.REPLACE)
    suspend fun insert(transaction: TransactionEntity): Long
    
    @Insert(onConflict = OnConflictStrategy.REPLACE)
    suspend fun insertAll(transactions: List<TransactionEntity>)
    
    @Update
    suspend fun update(transaction: TransactionEntity)
    
    @Delete
    suspend fun delete(transaction: TransactionEntity)
    
    @Query("SELECT * FROM transactions ORDER BY date DESC")
    fun getAllTransactions(): Flow<List<TransactionEntity>>
    
    @Query("SELECT * FROM transactions WHERE type = :type ORDER BY date DESC")
    fun getTransactionsByType(type: TransactionType): Flow<List<TransactionEntity>>
    
    @Query("SELECT * FROM transactions WHERE date >= :startDate AND date <= :endDate ORDER BY date DESC")
    fun getTransactionsByDateRange(startDate: LocalDateTime, endDate: LocalDateTime): Flow<List<TransactionEntity>>
    
    @Query("SELECT * FROM transactions WHERE categoryId = :categoryId ORDER BY date DESC")
    fun getTransactionsByCategory(categoryId: Long): Flow<List<TransactionEntity>>
    
    @Query("SELECT * FROM transactions WHERE isRecurring = 1")
    suspend fun getRecurringTransactions(): List<TransactionEntity>
    
    @Query("SELECT SUM(amount) FROM transactions WHERE type = :type AND date >= :startDate AND date <= :endDate")
    fun getTotalByType(type: TransactionType, startDate: LocalDateTime, endDate: LocalDateTime): Flow<Double?>
    
    @Query("SELECT * FROM transactions WHERE note LIKE '%' || :query || '%' ORDER BY date DESC")
    fun searchTransactions(query: String): Flow<List<TransactionEntity>>
    
    @Query("DELETE FROM transactions")
    suspend fun deleteAll()
    
    @Query("SELECT * FROM transactions WHERE id = :id")
    suspend fun getById(id: Long): TransactionEntity?
}
--- FILE: app/src/main/java/com/kharcha/app/data/dao/CategoryDao.kt ---

kotlin
package com.kharcha.app.data.dao

import androidx.room.*
import com.kharcha.app.data.model.CategoryEntity
import com.kharcha.app.data.model.TransactionType
import kotlinx.coroutines.flow.Flow

@Dao
interface CategoryDao {
    
    @Insert(onConflict = OnConflictStrategy.REPLACE)
    suspend fun insert(category: CategoryEntity): Long
    
    @Insert(onConflict = OnConflictStrategy.REPLACE)
    suspend fun insertAll(categories: List<CategoryEntity>)
    
    @Update
    suspend fun update(category: CategoryEntity)
    
    @Delete
    suspend fun delete(category: CategoryEntity)
    
    @Query("SELECT * FROM categories ORDER BY isDefault DESC, name ASC")
    fun getAllCategories(): Flow<List<CategoryEntity>>
    
    @Query("SELECT * FROM categories WHERE type = :type ORDER BY isDefault DESC, name ASC")
    fun getCategoriesByType(type: TransactionType): Flow<List<CategoryEntity>>
    
    @Query("SELECT * FROM categories WHERE name = :name AND type = :type LIMIT 1")
    suspend fun findByNameAndType(name: String, type: TransactionType): CategoryEntity?
    
    @Query("SELECT * FROM categories WHERE id = :id")
    suspend fun getById(id: Long): CategoryEntity?
}
--- FILE: app/src/main/java/com/kharcha/app/data/dao/AccountDao.kt ---

kotlin
package com.kharcha.app.data.dao

import androidx.room.*
import com.kharcha.app.data.model.AccountEntity
import kotlinx.coroutines.flow.Flow

@Dao
interface AccountDao {
    
    @Insert(onConflict = OnConflictStrategy.REPLACE)
    suspend fun insert(account: AccountEntity): Long
    
    @Update
    suspend fun update(account: AccountEntity)
    
    @Delete
    suspend fun delete(account: AccountEntity)
    
    @Query("SELECT * FROM accounts")
    fun getAllAccounts(): Flow<List<AccountEntity>>
    
    @Query("SELECT * FROM accounts WHERE id = :id")
    suspend fun getById(id: Long): AccountEntity?
}
--- FILE: app/src/main/java/com/kharcha/app/data/dao/AttachmentDao.kt ---

kotlin
package com.kharcha.app.data.dao

import androidx.room.*
import com.kharcha.app.data.model.AttachmentEntity
import kotlinx.coroutines.flow.Flow

@Dao
interface AttachmentDao {
    
    @Insert
    suspend fun insert(attachment: AttachmentEntity): Long
    
    @Delete
    suspend fun delete(attachment: AttachmentEntity)
    
    @Query("SELECT * FROM attachments WHERE transactionId = :transactionId")
    fun getAttachmentsByTransaction(transactionId: Long): Flow<List<AttachmentEntity>>
}
--- FILE: app/src/main/java/com/kharcha/app/data/repository/TransactionRepository.kt ---

kotlin
package com.kharcha.app.data.repository

import com.kharcha.app.data.dao.TransactionDao
import com.kharcha.app.data.model.TransactionEntity
import com.kharcha.app.data.model.TransactionType
import kotlinx.coroutines.flow.Flow
import java.time.LocalDateTime
import javax.inject.Inject
import javax.inject.Singleton

@Singleton
class TransactionRepository @Inject constructor(
    private val transactionDao: TransactionDao
) {
    fun getAllTransactions(): Flow<List<TransactionEntity>> = 
        transactionDao.getAllTransactions()
    
    fun getTransactionsByType(type: TransactionType): Flow<List<TransactionEntity>> =
        transactionDao.getTransactionsByType(type)
    
    fun getTransactionsByDateRange(
        startDate: LocalDateTime,
        endDate: LocalDateTime
    ): Flow<List<TransactionEntity>> =
        transactionDao.getTransactionsByDateRange(startDate, endDate)
    
    fun getTransactionsByCategory(categoryId: Long): Flow<List<TransactionEntity>> =
        transactionDao.getTransactionsByCategory(categoryId)
    
    suspend fun getRecurringTransactions(): List<TransactionEntity> =
        transactionDao.getRecurringTransactions()
    
    fun getTotalByType(
        type: TransactionType,
        startDate: LocalDateTime,
        endDate: LocalDateTime
    ): Flow<Double?> =
        transactionDao.getTotalByType(type, startDate, endDate)
    
    fun searchTransactions(query: String): Flow<List<TransactionEntity>> =
        transactionDao.searchTransactions(query)
    
    suspend fun insert(transaction: TransactionEntity): Long =
        transactionDao.insert(transaction)
    
    suspend fun insertAll(transactions: List<TransactionEntity>) =
        transactionDao.insertAll(transactions)
    
    suspend fun update(transaction: TransactionEntity) =
        transactionDao.update(transaction)
    
    suspend fun delete(transaction: TransactionEntity) =
        transactionDao.delete(transaction)
    
    suspend fun deleteAll() =
        transactionDao.deleteAll()
    
    suspend fun getById(id: Long): TransactionEntity? =
        transactionDao.getById(id)
}
--- FILE: app/src/main/java/com/kharcha/app/data/repository/CategoryRepository.kt ---

kotlin
package com.kharcha.app.data.repository

import com.kharcha.app.data.dao.CategoryDao
import com.kharcha.app.data.model.CategoryEntity
import com.kharcha.app.data.model.TransactionType
import kotlinx.coroutines.flow.Flow
import javax.inject.Inject
import javax.inject.Singleton

@Singleton
class CategoryRepository @Inject constructor(
    private val categoryDao: CategoryDao
) {
    fun getAllCategories(): Flow<List<CategoryEntity>> =
        categoryDao.getAllCategories()
    
    fun getCategoriesByType(type: TransactionType): Flow<List<CategoryEntity>> =
        categoryDao.getCategoriesByType(type)
    
    suspend fun findByNameAndType(name: String, type: TransactionType): CategoryEntity? =
        categoryDao.findByNameAndType(name, type)
    
    suspend fun insert(category: CategoryEntity): Long =
        categoryDao.insert(category)
    
    suspend fun insertAll(categories: List<CategoryEntity>) =
        categoryDao.insertAll(categories)
    
    suspend fun update(category: CategoryEntity) =
        categoryDao.update(category)
    
    suspend fun delete(category: CategoryEntity) =
        categoryDao.delete(category)
    
    suspend fun getById(id: Long): CategoryEntity? =
        categoryDao.getById(id)
}
--- FILE: app/src/main/java/com/kharcha/app/data/datastore/SettingsDataStore.kt ---

kotlin
package com.kharcha.app.data.datastore

import android.content.Context
import androidx.datastore.core.DataStore
import androidx.datastore.preferences.core.*
import androidx.datastore.preferences.preferencesDataStore
import androidx.security.crypto.EncryptedFile
import androidx.security.crypto.MasterKey
import dagger.hilt.android.qualifiers.ApplicationContext
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.map
import java.io.File
import javax.inject.Inject
import javax.inject.Singleton

private val Context.dataStore: DataStore<Preferences> by preferencesDataStore(name = "settings")

@Singleton
class SettingsDataStore @Inject constructor(
    @ApplicationContext private val context: Context
) {
    private val dataStore = context.dataStore
    
    companion object {
        val KEY_CURRENCY = stringPreferencesKey("currency")
        val KEY_PIN_HASH = stringPreferencesKey("pin_hash")
        val KEY_PIN_SALT = stringPreferencesKey("pin_salt")
        val KEY_BIOMETRIC_ENABLED = booleanPreferencesKey("biometric_enabled")
        val KEY_SMS_AUTO_PARSE = booleanPreferencesKey("sms_auto_parse")
        val KEY_DARK_MODE = booleanPreferencesKey("dark_mode")
    }
    
    val currency: Flow<String> = dataStore.data.map { prefs ->
        prefs[KEY_CURRENCY] ?: "INR"
    }
    
    val pinHash: Flow<String?> = dataStore.data.map { prefs ->
        prefs[KEY_PIN_HASH]
    }
    
    val pinSalt: Flow<String?> = dataStore.data.map { prefs ->
        prefs[KEY_PIN_SALT]
    }
    
    val biometricEnabled: Flow<Boolean> = dataStore.data.map { prefs ->
        prefs[KEY_BIOMETRIC_ENABLED] ?: false
    }
    
    val smsAutoParseEnabled: Flow<Boolean> = dataStore.data.map { prefs ->
        prefs[KEY_SMS_AUTO_PARSE] ?: false
    }
    
    val darkMode: Flow<Boolean> = dataStore.data.map { prefs ->
        prefs[KEY_DARK_MODE] ?: false
    }
    
    suspend fun setCurrency(currency: String) {
        dataStore.edit { prefs ->
            prefs[KEY_CURRENCY] = currency
        }
    }
    
    suspend fun setPinCredentials(hash: String, salt: String) {
        dataStore.edit { prefs ->
            prefs[KEY_PIN_HASH] = hash
            prefs[KEY_PIN_SALT] = salt
        }
    }
    
    suspend fun clearPin() {
        dataStore.edit { prefs ->
            prefs.remove(KEY_PIN_HASH)
            prefs.remove(KEY_PIN_SALT)
        }
    }
    
    suspend fun setBiometricEnabled(enabled: Boolean) {
        dataStore.edit { prefs ->
            prefs[KEY_BIOMETRIC_ENABLED] = enabled
        }
    }
    
    suspend fun setSmsAutoParseEnabled(enabled: Boolean) {
        dataStore.edit { prefs ->
            prefs[KEY_SMS_AUTO_PARSE] = enabled
        }
    }
    
    suspend fun setDarkMode(enabled: Boolean) {
        dataStore.edit { prefs ->
            prefs[KEY_DARK_MODE] = enabled
        }
    }
}
--- FILE: app/src/main/java/com/kharcha/app/security/PinManager.kt ---

kotlin
package com.kharcha.app.security

import com.kharcha.app.data.datastore.SettingsDataStore
import kotlinx.coroutines.flow.first
import java.security.SecureRandom
import javax.crypto.SecretKeyFactory
import javax.crypto.spec.PBEKeySpec
import javax.inject.Inject
import javax.inject.Singleton

@Singleton
class PinManager @Inject constructor(
    private val settingsDataStore: SettingsDataStore
) {
    companion object {
        private const val ITERATIONS = 10000
        private const val KEY_LENGTH = 256
    }
    
    suspend fun setPin(pin: String) {
        val salt = generateSalt()
        val hash = hashPin(pin, salt)
        settingsDataStore.setPinCredentials(hash, salt)
    }
    
    suspend fun verifyPin(pin: String): Boolean {
        val storedHash = settingsDataStore.pinHash.first() ?: return false
        val salt = settingsDataStore.pinSalt.first() ?: return false
        val hash = hashPin(pin, salt)
        return hash == storedHash
    }
    
    suspend fun isPinSet(): Boolean {
        return settingsDataStore.pinHash.first() != null
    }
    
    suspend fun clearPin() {
        settingsDataStore.clearPin()
    }
    
    private fun hashPin(pin: String, salt: String): String {
        val spec = PBEKeySpec(pin.toCharArray(), salt.toByteArray(), ITERATIONS, KEY_LENGTH)
        val factory = SecretKeyFactory.getInstance("PBKDF2WithHmacSHA256")
        val hash = factory.generateSecret(spec).encoded
        return hash.joinToString("") { "%02x".format(it) }
    }
    
    private fun generateSalt(): String {
        val random = SecureRandom()
        val salt = ByteArray(16)
        random.nextBytes(salt)
        return salt.joinToString("") { "%02x".format(it) }
    }
}
--- FILE: app/src/main/java/com/kharcha/app/utils/RecurrenceHelper.kt ---

kotlin
package com.kharcha.app.utils

import com.kharcha.app.data.model.RecurrenceType
import com.kharcha.app.data.model.TransactionEntity
import com.kharcha.app.data.repository.TransactionRepository
import java.time.LocalDate
import java.time.LocalDateTime
import javax.inject.Inject
import javax.inject.Singleton

@Singleton
class RecurrenceHelper @Inject constructor(
    private val transactionRepository: TransactionRepository
) {
    
    suspend fun processRecurringTransactions() {
        val recurring = transactionRepository.getRecurringTransactions()
        val today = LocalDate.now()
        
        recurring.forEach { transaction ->
            val lastProcessed = transaction.lastProcessedDate ?: transaction.date.toLocalDate()
            val nextDate = calculateNextDate(lastProcessed, transaction.recurrenceType!!)
            
            if (!nextDate.isAfter(today)) {
                // Create new transaction instance
                val newTransaction = transaction.copy(
                    id = 0,
                    date = nextDate.atTime(transaction.date.toLocalTime()),
                    isRecurring = false
                )
                transactionRepository.insert(newTransaction)
                
                // Update last processed date
                val updated = transaction.copy(lastProcessedDate = nextDate)
                transactionRepository.update(updated)
            }
        }
    }
    
    fun calculateNextDate(lastDate: LocalDate, recurrenceType: RecurrenceType): LocalDate {
        return when (recurrenceType) {
            RecurrenceType.DAILY -> lastDate.plusDays(1)
            RecurrenceType.WEEKLY -> lastDate.plusWeeks(1)
            RecurrenceType.MONTHLY -> {
                // Handle end-of-month edge cases properly
                val nextMonth = lastDate.plusMonths(1)
                val dayOfMonth = lastDate.dayOfMonth
                val lastDayOfNextMonth = nextMonth.lengthOfMonth()
                
                if (dayOfMonth > lastDayOfNextMonth) {
                    nextMonth.withDayOfMonth(lastDayOfNextMonth)
                } else {
                    nextMonth.withDayOfMonth(dayOfMonth)
                }
            }
            RecurrenceType.YEARLY -> lastDate.plusYears(1)
        }
    }
}
--- FILE: app/src/main/java/com/kharcha/app/ml/BaselinePredictor.kt ---

kotlin
package com.kharcha.app.ml

import com.kharcha.app.data.model.TransactionEntity
import com.kharcha.app.data.model.TransactionType
import java.time.YearMonth
import javax.inject.Inject
import javax.inject.Singleton
import kotlin.math.pow
import kotlin.math.sqrt

@Singleton
class BaselinePredictor @Inject constructor() {
    
    companion object {
        // Configurable weights for weighted moving average
        // More weight to recent months
        private val WEIGHTS = listOf(0.5, 0.3, 0.2)
        private const val ANOMALY_THRESHOLD = 2.0 // Z-score threshold
    }
    
    fun predictNextMonthExpense(transactions: List<TransactionEntity>): Double {
        val expenses = transactions.filter { it.type == TransactionType.EXPENSE }
        
        val monthlyTotals = expenses
            .groupBy { YearMonth.from(it.date) }
            .mapValues { entry -> entry.value.sumOf { it.amount } }
            .toSortedMap(compareByDescending { it })
        
        if (monthlyTotals.size < WEIGHTS.size) {
            return monthlyTotals.values.average()
        }
        
        val lastMonths = monthlyTotals.values.take(WEIGHTS.size).toList()
        val weightedSum = lastMonths.zip(WEIGHTS).sumOf { (amount, weight) -> amount * weight }
        
        return weightedSum
    }
    
    fun detectAnomalies(transactions: List<TransactionEntity>): List<TransactionEntity> {
        val expenses = transactions.filter { it.type == TransactionType.EXPENSE }
        
        val categoryGroups = expenses.groupBy { it.categoryId }
        val anomalies = mutableListOf<TransactionEntity>()
        
        categoryGroups.forEach { (_, categoryTransactions) ->
            if (categoryTransactions.size < 3) return@forEach
            
            val amounts = categoryTransactions.map { it.amount }
            val mean = amounts.average()
            val stdDev = sqrt(amounts.map { (it - mean).pow(2) }.average())
            
            if (stdDev == 0.0) return@forEach
            
            categoryTransactions.forEach { transaction ->
                val zScore = (transaction.amount - mean) / stdDev
                if (zScore > ANOMALY_THRESHOLD) {
                    anomalies.add(transaction)
                }
            }
        }
        
        return anomalies
    }
    
    fun recommendBudget(transactions: List<TransactionEntity>, months: Int = 3): Map<Long, Double> {
        val expenses = transactions.filter { it.type == TransactionType.EXPENSE }
        
        return expenses
            .groupBy { it.categoryId }
            .mapValues { (_, categoryTransactions) ->
                val monthlyGroups = categoryTransactions
                    .groupBy { YearMonth.from(it.date) }
                    .mapValues { entry -> entry.value.sumOf { it.amount } }
                
                if (monthlyGroups.isEmpty()) return@mapValues 0.0
                
                val lastNMonths = monthlyGroups.entries
                    .sortedByDescending { it.key }
                    .take(months)
                    .map { it.value }
                
                lastNMonths.average() * 1.1 // Add 10% buffer
            }
    }
}
--- FILE: app/src/main/java/com/kharcha/app/ml/TFLiteModelInterface.kt ---

kotlin
package com.kharcha.app.ml

import javax.inject.Inject
import javax.inject.Singleton

@Singleton
class TFLiteModelInterface @Inject constructor() {
    
    // Placeholder for TensorFlow Lite model integration
    // This provides a clean interface for future ML model integration
    
    private var isModelLoaded = false
    
    fun loadModel(): Boolean {
        // TODO: Load TFLite model from assets
        // For now, return false to indicate baseline predictor should be used
        isModelLoaded = false
        return isModelLoaded
    }
    
    fun predict(features: FloatArray): Float {
        if (!isModelLoaded) {
            throw IllegalStateException("Model not loaded. Use BaselinePredictor instead.")
        }
        
        // TODO: Run inference with TFLite model
        return 0f
    }
    
    fun isAvailable(): Boolean = isModelLoaded
}
--- FILE: app/src/main/java/com/kharcha/app/importexport/ExportManager.kt ---

kotlin
package com.kharcha.app.importexport

import android.content.Context
import android.net.Uri
import com.kharcha.app.data.model.CategoryEntity
import com.kharcha.app.data.model.TransactionEntity
import com.kharcha.app.data.repository.CategoryRepository
import com.kharcha.app.data.repository.TransactionRepository
import com.opencsv.CSVWriter
import dagger.hilt.android.qualifiers.ApplicationContext
import kotlinx.coroutines.flow.first
import kotlinx.serialization.Serializable
import kotlinx.serialization.encodeToString
import kotlinx.serialization.json.Json
import org.apache.poi.ss.usermodel.WorkbookFactory
import org.apache.poi.xssf.usermodel.XSSFWorkbook
import java.io.OutputStreamWriter
import java.time.format.DateTimeFormatter
import javax.inject.Inject
import javax.inject.Singleton

@Singleton
class ExportManager @Inject constructor(
    @ApplicationContext private val context: Context,
    private val transactionRepository: TransactionRepository,
    private val categoryRepository: CategoryRepository
) {
    
    suspend fun exportToCsv(uri: Uri) {
        val transactions = transactionRepository.getAllTransactions().first()
        
        context.contentResolver.openOutputStream(uri)?.use { outputStream ->
            val writer = CSVWriter(OutputStreamWriter(outputStream))
            
            // Write header
            writer.writeNext(arrayOf(
                "ID", "Type", "Amount", "Currency", "Date", "Category", 
                "Account", "Note", "IsRecurring", "RecurrenceType"
            ))
            
            // Write data
            transactions.forEach { transaction ->
                writer.writeNext(arrayOf(
                    transaction.id.toString(),
                    transaction.type.name,
                    transaction.amount.toString(),
                    transaction.currency,
                    transaction.date.format(DateTimeFormatter.ISO_LOCAL_DATE_TIME),
                    transaction.categoryId.toString(),
                    transaction.accountId?.toString() ?: "",
                    transaction.note,
                    transaction.isRecurring.toString(),
                    transaction.recurrenceType?.name ?: ""
                ))
            }
            
            writer.close()
        }
    }
    
    suspend fun exportToJson(uri: Uri) {
        val transactions = transactionRepository.getAllTransactions().first()
        val categories = categoryRepository.getAllCategories().first()
        
        val backup = BackupData(
            transactions = transactions.map { it.toSerializable() },
            categories = categories.map { it.toSerializable() }
        )
        
        val json = Json { prettyPrint = true }
        val jsonString = json.encodeToString(backup)
        
        context.contentResolver.openOutputStream(uri)?.use { outputStream ->
            outputStream.write(jsonString.toByteArray())
        }
    }
    
    suspend fun exportToXlsx(uri: Uri) {
        val transactions = transactionRepository.getAllTransactions().first()
        val categories = categoryRepository.getAllCategories().first()
        
        val workbook = XSSFWorkbook()
        
        // Transactions sheet
        val transactionSheet = workbook.createSheet("Transactions")
        val transHeaderRow = transactionSheet.createRow(0)
        val transHeaders = listOf("ID", "Type", "Amount", "Currency", "Date", "Category", "Account", "Note", "IsRecurring", "RecurrenceType")
        transHeaders.forEachIndexed { index, header ->
            transHeaderRow.createCell(index).setCellValue(header)
        }
        
        transactions.forEachIndexed { index, transaction ->
            val row = transactionSheet.createRow(index + 1)
            row.createCell(0).setCellValue(transaction.id.toDouble())
            row.createCell(1).setCellValue(transaction.type.name)
            row.createCell(2).setCellValue(transaction.amount)
            row.createCell(3).setCellValue(transaction.currency)
            row.createCell(4).setCellValue(transaction.date.format(DateTimeFormatter.ISO_LOCAL_DATE_TIME))
            row.createCell(5).setCellValue(transaction.categoryId.toDouble())
            row.createCell(6).setCellValue(transaction.accountId?.toDouble() ?: 0.0)
            row.createCell(7).setCellValue(transaction.note)
            row.createCell(8).setCellValue(transaction.isRecurring)
            row.createCell(9).setCellValue(transaction.recurrenceType?.name ?: "")
        }
        
        // Categories sheet
        val categorySheet = workbook.createSheet("Categories")
        val catHeaderRow = categorySheet.createRow(0)
        val catHeaders = listOf("ID", "Name", "Type", "IsDefault")
        catHeaders.forEachIndexed { index, header ->
            catHeaderRow.createCell(index).setCellValue(header)
        }
        
        categories.forEachIndexed { index, category ->
            val row = categorySheet.createRow(index + 1)
            row.createCell(0).setCellValue(category.id.toDouble())
            row.createCell(1).setCellValue(category.name)
            row.createCell(2).setCellValue(category.type.name)
            row.createCell(3).setCellValue(category.isDefault)
        }
        
        context.contentResolver.openOutputStream(uri)?.use { outputStream ->
            workbook.write(outputStream)
            workbook.close()
        }
    }
}

@Serializable
data class BackupData(
    val transactions: List<SerializableTransaction>,
    val categories: List<SerializableCategory>
)

@Serializable
data class SerializableTransaction(
    val id: Long,
    val type: String,
    val amount: Double,
    val currency: String,
    val date: String,
    val categoryId: Long,
    val accountId: Long?,
    val note: String,
    val metadata: String,
    val isRecurring: Boolean,
    val recurrenceType: String?,
    val lastProcessedDate: String?
)

@Serializable
data class SerializableCategory(
    val id: Long,
    val name: String,
    val type: String,
    val icon: String?,
    val color: String?,
    val isDefault: Boolean
)

private fun TransactionEntity.toSerializable() = SerializableTransaction(
    id = id,
    type = type.name,
    amount = amount,
    currency = currency,
    date = date.format(DateTimeFormatter.ISO_LOCAL_DATE_TIME),
    categoryId = categoryId,
    accountId = accountId,
    note = note,
    metadata = metadata,
    isRecurring = isRecurring,
    recurrenceType = recurrenceType?.name,
    lastProcessedDate = lastProcessedDate?.format(DateTimeFormatter.ISO_DATE)
)

private fun CategoryEntity.toSerializable() = SerializableCategory(
    id = id,
    name = name,
    type = type.name,
    icon = icon,
    color = color,
    isDefault = isDefault
)
--- FILE: app/src/main/java/com/kharcha/app/importexport/ImportManager.kt ---

kotlin
package com.kharcha.app.importexport

import android.content.Context
import android.net.Uri
import com.kharcha.app.data.datastore.SettingsDataStore
import com.kharcha.app.data.model.CategoryEntity
import com.kharcha.app.data.model.RecurrenceType
import com.kharcha.app.data.model.TransactionEntity
import com.kharcha.app.data.model.TransactionType
import com.kharcha.app.data.repository.CategoryRepository
import com.kharcha.app.data.repository.TransactionRepository
import com.opencsv.CSVParserBuilder
import com.opencsv.CSVReaderBuilder
import dagger.hilt.android.qualifiers.ApplicationContext
import kotlinx.coroutines.flow.first
import kotlinx.serialization.json.Json
import org.apache.poi.ss.usermodel.WorkbookFactory
import java.io.InputStreamReader
import java.time.LocalDate
import java.time.LocalDateTime
import java.time.format.DateTimeFormatter
import java.time.format.DateTimeParseException
import javax.inject.Inject
import javax.inject.Singleton

@Singleton
class ImportManager @Inject constructor(
    @ApplicationContext private val context: Context,
    private val transactionRepository: TransactionRepository,
    private val categoryRepository: CategoryRepository,
    private val settingsDataStore: SettingsDataStore
) {
    
    private val dateFormatters = listOf(
        DateTimeFormatter.ISO_LOCAL_DATE_TIME,
        DateTimeFormatter.ISO_LOCAL_DATE,
        DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss"),
        DateTimeFormatter.ofPattern("yyyy-MM-dd"),
        DateTimeFormatter.ofPattern("dd/MM/yyyy"),
        DateTimeFormatter.ofPattern("MM/dd/yyyy"),
        DateTimeFormatter.ofPattern("dd-MM-yyyy"),
        DateTimeFormatter.ofPattern("MM-dd-yyyy")
    )
    
    suspend fun importFromCsv(uri: Uri) {
        val defaultCurrency = settingsDataStore.currency.first()
        
        context.contentResolver.openInputStream(uri)?.use { inputStream ->
            val parser = CSVParserBuilder().withSeparator(',').build()
            val reader = CSVReaderBuilder(InputStreamReader(inputStream))
                .withCSVParser(parser)
                .build()
            
            val allRows = reader.readAll()
            if (allRows.isEmpty()) return
            
            val headers = allRows[0].map { it.trim().lowercase() }
            val dataRows = allRows.drop(1)
            
            // Flexible header mapping
            val typeIdx = headers.indexOfFirst { it.contains("type") }
            val amountIdx = headers.indexOfFirst { it.contains("amount") }
            val currencyIdx = headers.indexOfFirst { it.contains("currency") }
            val dateIdx = headers.indexOfFirst { it.contains("date") }
            val categoryIdx = headers.indexOfFirst { it.contains("category") }
            val noteIdx = headers.indexOfFirst { it.contains("note") }
            val recurringIdx = headers.indexOfFirst { it.contains("recurring") }
            val recurrenceTypeIdx = headers.indexOfFirst { it.contains("recurrence") && it.contains("type") }
            
            val transactions = dataRows.mapNotNull { row ->
                try {
                    val type = if (typeIdx >= 0) parseTransactionType(row[typeIdx].trim()) else TransactionType.EXPENSE
                    val amount = if (amountIdx >= 0) row[amountIdx].trim().toDoubleOrNull() ?: 0.0 else 0.0
                    val currency = if (currencyIdx >= 0) row[currencyIdx].trim().ifEmpty { defaultCurrency } else defaultCurrency
                    val date = if (dateIdx >= 0) parseDate(row[dateIdx].trim()) else LocalDateTime.now()
                    val categoryName = if (categoryIdx >= 0) row[categoryIdx].trim() else "Uncategorized"
                    val note = if (noteIdx >= 0) row[noteIdx].trim() else ""
                    val isRecurring = if (recurringIdx >= 0) row[recurringIdx].trim().toBoolean() else false
                    val recurrenceType = if (recurrenceTypeIdx >= 0 && isRecurring) {
                        parseRecurrenceType(row[recurrenceTypeIdx].trim())
                    } else null
                    
                    // Find or create category
                    var category = categoryRepository.findByNameAndType(categoryName, type)
                    if (category == null) {
                        val newCategoryId = categoryRepository.insert(
                            CategoryEntity(name = categoryName, type = type)
                        )
                        category = categoryRepository.getById(newCategoryId)
                    }
                    
                    TransactionEntity(
                        type = type,
                        amount = amount,
                        currency = currency,
                        date = date,
                        categoryId = category?.id ?: 1,
                        note = note,
                        isRecurring = isRecurring,
                        recurrenceType = recurrenceType
                    )
                } catch (e: Exception) {
                    null
                }
            }
            
            transactionRepository.insertAll(transactions)
        }
    }
    
    suspend fun importFromXlsx(uri: Uri) {
        val defaultCurrency = settingsDataStore.currency.first()
        
        context.contentResolver.openInputStream(uri)?.use { inputStream ->
            val workbook = WorkbookFactory.create(inputStream)
            val sheet = workbook.getSheetAt(0)
            
            if (sheet.physicalNumberOfRows == 0) return
            
            val headerRow = sheet.getRow(0)
            val headers = (0 until headerRow.lastCellNum).map {
                headerRow.getCell(it)?.stringCellValue?.trim()?.lowercase() ?: ""
            }
            
            val typeIdx = headers.indexOfFirst { it.contains("type") }
            val amountIdx = headers.indexOfFirst { it.contains("amount") }
            val currencyIdx = headers.indexOfFirst { it.contains("currency") }
            val dateIdx = headers.indexOfFirst { it.contains("date") }
            val categoryIdx = headers.indexOfFirst { it.contains("category") }
            val noteIdx = headers.indexOfFirst { it.contains("note") }
            val recurringIdx = headers.indexOfFirst { it.contains("recurring") }
            val recurrenceTypeIdx = headers.indexOfFirst { it.contains("recurrence") && it.contains("type") }
            
            val transactions = (1 until sheet.physicalNumberOfRows).mapNotNull { rowIdx ->
                try {
                    val row = sheet.getRow(rowIdx)
                    
                    val type = if (typeIdx >= 0) parseTransactionType(row.getCell(typeIdx)?.stringCellValue ?: "") else TransactionType.EXPENSE
                    val amount = if (amountIdx >= 0) row.getCell(amountIdx)?.numericCellValue ?: 0.0 else 0.0
                    val currency = if (currencyIdx >= 0) {
                        row.getCell(currencyIdx)?.stringCellValue?.trim()?.ifEmpty { defaultCurrency } ?: defaultCurrency
                    } else defaultCurrency
                    val date = if (dateIdx >= 0) {
                        parseDate(row.getCell(dateIdx)?.stringCellValue ?: "")
                    } else LocalDateTime.now()
                    val categoryName = if (categoryIdx >= 0) {
                        row.getCell(categoryIdx)?.stringCellValue?.trim() ?: "Uncategorized"
                    } else "Uncategorized"
                    val note = if (noteIdx >= 0) row.getCell(noteIdx)?.stringCellValue ?: "" else ""
                    val isRecurring = if (recurringIdx >= 0) {
                        row.getCell(recurringIdx)?.booleanCellValue ?: false
                    } else false
                    val recurrenceType = if (recurrenceTypeIdx >= 0 && isRecurring) {
                        parseRecurrenceType(row.getCell(recurrenceTypeIdx)?.stringCellValue ?: "")
                    } else null
                    
                    var category = categoryRepository.findByNameAndType(categoryName, type)
                    if (category == null) {
                        val newCategoryId = categoryRepository.insert(
                            CategoryEntity(name = categoryName, type = type)
                        )
                        category = categoryRepository.getById(newCategoryId)
                    }
                    
                    TransactionEntity(
                        type = type,
                        amount = amount,
                        currency = currency,
                        date = date,
                        categoryId = category?.id ?: 1,
                        note = note,
                        isRecurring = isRecurring,
                        recurrenceType = recurrenceType
                    )
                } catch (e: Exception) {
                    null
                }
            }
            
            transactionRepository.insertAll(transactions)
            workbook.close()
        }
    }
    
    suspend fun importFromJson(uri: Uri) {
        context.contentResolver.openInputStream(uri)?.use { inputStream ->
            val jsonString = inputStream.bufferedReader().use { it.readText() }
            val backup = Json.decodeFromString<BackupData>(jsonString)
            
            // Import categories first
            backup.categories.forEach { serializableCategory ->
                val existing = categoryRepository.findByNameAndType(
                    serializableCategory.name,
                    TransactionType.valueOf(serializableCategory.type)
                )
                if (existing == null) {
                    categoryRepository.insert(
                        CategoryEntity(
                            name = serializableCategory.name,
                            type = TransactionType.valueOf(serializableCategory.type),
                            icon = serializableCategory.icon,
                            color = serializableCategory.color,
                            isDefault = serializableCategory.isDefault
                        )
                    )
                }
            }
            
            // Import transactions
            val transactions = backup.transactions.map { serializable ->
                TransactionEntity(
                    type = TransactionType.valueOf(serializable.type),
                    amount = serializable.amount,
                    currency = serializable.currency,
                    date = LocalDateTime.parse(serializable.date, DateTimeFormatter.ISO_LOCAL_DATE_TIME),
                    categoryId = serializable.categoryId,
                    accountId = serializable.accountId,
                    note = serializable.note,
                    metadata = serializable.metadata,
                    isRecurring = serializable.isRecurring,
                    recurrenceType = serializable.recurrenceType?.let { RecurrenceType.valueOf(it) },
                    lastProcessedDate = serializable.lastProcessedDate?.let { LocalDate.parse(it, DateTimeFormatter.ISO_DATE) }
                )
            }
            
            transactionRepository.insertAll(transactions)
        }
    }
    
    private fun parseDate(dateString: String): LocalDateTime {
        for (formatter in dateFormatters) {
            try {
                return try {
                    LocalDateTime.parse(dateString, formatter)
                } catch (e: DateTimeParseException) {
                    LocalDate.parse(dateString, formatter).atStartOfDay()
                }
            } catch (e: DateTimeParseException) {
                continue
            }
        }
        return LocalDateTime.now()
    }
    
    private fun parseTransactionType(value: String): TransactionType {
        return when (value.uppercase()) {
            "INCOME", "IN" -> TransactionType.INCOME
            "TRANSFER", "TRANS" -> TransactionType.TRANSFER
            else -> TransactionType.EXPENSE
        }
    }
    
    private fun parseRecurrenceType(value: String): RecurrenceType? {
        return when (value.uppercase()) {
            "DAILY" -> RecurrenceType.DAILY
            "WEEKLY" -> RecurrenceType.WEEKLY
            "MONTHLY" -> RecurrenceType.MONTHLY
            "YEARLY" -> RecurrenceType.YEARLY
            else -> null
        }
    }
}
--- FILE: app/src/main/java/com/kharcha/app/ocr/ReceiptScanner.kt ---

kotlin
package com.kharcha.app.ocr

import android.graphics.Bitmap
import com.google.mlkit.vision.common.InputImage
import com.google.mlkit.vision.text.TextRecognition
import com.google.mlkit.vision.text.latin.TextRecognizerOptions
import kotlinx.coroutines.tasks.await
import java.time.LocalDate
import java.time.format.DateTimeFormatter
import javax.inject.Inject
import javax.inject.Singleton

@Singleton
class ReceiptScanner @Inject constructor() {
    
    private val recognizer = TextRecognition.getClient(TextRecognizerOptions.DEFAULT_OPTIONS)
    
    suspend fun scanReceipt(bitmap: Bitmap): ReceiptData {
        val image = InputImage.fromBitmap(bitmap, 0)
        val result = recognizer.process(image).await()
        val text = result.text
        
        return parseReceiptText(text)
    }
    
    private fun parseReceiptText(text: String): ReceiptData {
        val lines = text.lines().map { it.trim() }
        
        var amount: Double? = null
        var date: LocalDate? = null
        var merchant: String? = null
        
        // Extract amount using regex patterns
        val amountPatterns = listOf(
            Regex("""(?i)(total|amount|balance|paid)\s*:?\s*(?:rs\.?|)?\s*([0-9,]+\.?[0-9]*)"""),
            Regex("""(?:rs\.?|)\s*([0-9,]+\.?[0-9]*)"""),
            Regex("""([0-9,]+\.[0-9]{2})""")
        )
        
        for (line in lines) {
            for (pattern in amountPatterns) {
                val match = pattern.find(line)
                if (match != null) {
                    val amountStr = match.groupValues.last().replace(",", "")
                    amount = amountStr.toDoubleOrNull()
                    if (amount != null) break
                }
            }
            if (amount != null) break
        }
        
        // Extract date
        val datePatterns = listOf(
            DateTimeFormatter.ofPattern("dd/MM/yyyy"),
            DateTimeFormatter.ofPattern("dd-MM-yyyy"),
            DateTimeFormatter.ofPattern("yyyy-MM-dd"),
            DateTimeFormatter.ofPattern("dd MMM yyyy")
        )
        
        for (line in lines) {
            for (formatter in datePatterns) {
                try {
                    date = LocalDate.parse(line, formatter)
                    break
                } catch (e: Exception) {
                    continue
                }
            }
            if (date != null) break
        }
        
        // Extract merchant (usually first non-empty line)
        merchant = lines.firstOrNull { it.isNotBlank() && it.length > 3 }
        
        return ReceiptData(
            amount = amount,
            date = date,
            merchant = merchant,
            rawText = text
        )
    }
}

data class ReceiptData(
    val amount: Double?,
    val date: LocalDate?,
    val merchant: String?,
    val rawText: String
)
--- FILE: app/src/main/java/com/kharcha/app/voice/VoiceInputParser.kt ---

kotlin
package com.kharcha.app.voice

import com.kharcha.app.data.model.TransactionType
import java.time.LocalDate
import java.time.LocalDateTime
import javax.inject.Inject
import javax.inject.Singleton

@Singleton
class VoiceInputParser @Inject constructor() {
    
    fun parseVoiceInput(text: String): VoiceTransactionData {
        val lowerText = text.lowercase()
        
        // Determine transaction type
        val type = when {
            lowerText.contains("spent") || lowerText.contains("paid") || lowerText.contains("expense") -> TransactionType.EXPENSE
            lowerText.contains("received") || lowerText.contains("earned") || lowerText.contains("income") -> TransactionType.INCOME
            else -> TransactionType.EXPENSE
        }
        
        // Extract amount
        val amountRegex = Regex("""(\d+(?:\.\d{1,2})?)""")
        val amount = amountRegex.find(lowerText)?.groupValues?.get(1)?.toDoubleOrNull()
        
        // Extract category
        val categoryKeywords = mapOf(
            "food" to listOf("food", "lunch", "dinner", "breakfast", "restaurant", "ate"),
            "transport" to listOf("transport", "uber", "taxi", "bus", "metro", "train"),
            "shopping" to listOf("shopping", "bought", "purchase"),
            "entertainment" to listOf("movie", "entertainment", "game"),
            "groceries" to listOf("groceries", "grocery", "supermarket")
        )
        
        var category = "Uncategorized"
        for ((cat, keywords) in categoryKeywords) {
            if (keywords.any { lowerText.contains(it) }) {
                category = cat.capitalize()
                break
            }
        }
        
        // Extract date (today, yesterday, etc.)
        val date = when {
            lowerText.contains("yesterday") -> LocalDate.now().minusDays(1)
            lowerText.contains("today") -> LocalDate.now()
            else -> LocalDate.now()
        }
        
        // Extract note
        val note = text
        
        return VoiceTransactionData(
            type = type,
            amount = amount,
            category = category,
            date = date.atStartOfDay(),
            note = note
        )
    }
}

data class VoiceTransactionData(
    val type: TransactionType,
    val amount: Double?,
    val category: String,
    val date: LocalDateTime,
    val note: String
)
--- FILE: app/src/main/java/com/kharcha/app/sms/SmsReceiver.kt ---

kotlin
package com.kharcha.app.sms

import android.content.BroadcastReceiver
import android.content.Context
import android.content.Intent
import android.provider.Telephony
import com.kharcha.app.data.datastore.SettingsDataStore
import dagger.hilt.android.AndroidEntryPoint
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.flow.first
import kotlinx.coroutines.launch
import javax.inject.Inject

@AndroidEntryPoint
class SmsReceiver : BroadcastReceiver() {
    
    @Inject
    lateinit var smsParser: SmsParser
    
    @Inject
    lateinit var settingsDataStore: SettingsDataStore
    
    override fun onReceive(context: Context, intent: Intent) {
        if (intent.action != Telephony.Sms.Intents.SMS_RECEIVED_ACTION) return
        
        CoroutineScope(Dispatchers.IO).launch {
            val enabled = settingsDataStore.smsAutoParseEnabled.first()
            if (!enabled) return@launch
            
            val messages = Telephony.Sms.Intents.getMessagesFromIntent(intent)
            for (sms in messages) {
                val body = sms.messageBody
                val sender = sms.originatingAddress ?: ""
                
                smsParser.parseSms(sender, body)
            }
        }
    }
}
--- FILE: app/src/main/java/com/kharcha/app/sms/SmsParser.kt ---

kotlin
package com.kharcha.app.sms

import com.kharcha.app.data.model.TransactionEntity
import com.kharcha.app.data.model.TransactionType
import com.kharcha.app.data.repository.CategoryRepository
import com.kharcha.app.data.repository.TransactionRepository
import java.time.LocalDateTime
import javax.inject.Inject
import javax.inject.Singleton

@Singleton
class SmsParser @Inject constructor(
    private val transactionRepository: TransactionRepository,
    private val categoryRepository: CategoryRepository
) {
    
    // Common Indian bank/UPI SMS patterns
    private val upiPatterns = listOf(
        Regex("""(?i)debited.*?rs\.?\s*([0-9,]+\.?[0-9]*)"""),
        Regex("""(?i)credited.*?rs\.?\s*([0-9,]+\.?[0-9]*)"""),
        Regex("""(?i)spent.*?rs\.?\s*([0-9,]+\.?[0-9]*)"""),
        Regex("""(?i)received.*?rs\.?\s*([0-9,]+\.?[0-9]*)"""),
        Regex("""(?i)paid.*?rs\.?\s*([0-9,]+\.?[0-9]*)"""),
        Regex("""(?i)transferred.*?rs\.?\s*([0-9,]+\.?[0-9]*)""")
    )
    
    suspend fun parseSms(sender: String, body: String) {
        // Check if SMS is from known bank/payment service
        if (!isFinancialSms(sender)) return
        
        val lowerBody = body.lowercase()
        
        // Determine transaction type
        val type = when {
            lowerBody.contains("debited") || lowerBody.contains("spent") || lowerBody.contains("paid") -> TransactionType.EXPENSE
            lowerBody.contains("credited") || lowerBody.contains("received") -> TransactionType.INCOME
            else -> return
        }
        
        // Extract amount
        var amount: Double? = null
        for (pattern in upiPatterns) {
            val match = pattern.find(body)
            if (match != null) {
                val amountStr = match.groupValues[1].replace(",", "")
                amount = amountStr.toDoubleOrNull()
                if (amount != null) break
            }
        }
        
        if (amount == null || amount <= 0) return
        
        // Extract merchant/payee
        val merchantPatterns = listOf(
            Regex("""(?i)(?:to|at|from)\s+([A-Z][A-Za-z0-9\s]{2,30})"""),
            Regex("""(?i)UPI-([A-Za-z0-9\s]{2,30})""")
        )
        
        var merchant: String? = null
        for (pattern in merchantPatterns) {
            val match = pattern.find(body)
            if (match != null) {
                merchant = match.groupValues[1].trim()
                break
            }
        }
        
        // Find or create category
        val categoryName = merchant ?: "UPI Transaction"
        var category = categoryRepository.findByNameAndType(categoryName, type)
        if (category == null) {
            val catId = categoryRepository.insert(
                com.kharcha.app.data.model.CategoryEntity(
                    name = categoryName,
                    type = type
                )
            )
            category = categoryRepository.getById(catId)
        }
        
        // Create transaction with SMS metadata
        val transaction = TransactionEntity(
            type = type,
            amount = amount,
            currency = "INR",
            date = LocalDateTime.now(),
            categoryId = category?.id ?: 1,
            note = "Auto-imported from SMS",
            metadata = """{"source":"sms","sender":"$sender","merchant":"$merchant"}"""
        )
        
        transactionRepository.insert(transaction)
    }
    
    private fun isFinancialSms(sender: String): Boolean {
        val financialSenders = listOf(
            "SBIINB", "HDFCBK", "ICICIB", "AXISBK", "KOTAKB", "PNBSMS",
            "CANBNK", "UNIONB", "BOIIND", "MAHABK",
            "ATMSBI", "PAYTM", "GOOGLE", "AMAZONP", "PHONEPE", "BHARPE"
        )
        return financialSenders.any { sender.contains(it, ignoreCase = true) }
    }
}
--- FILE: app/src/main/java/com/kharcha/app/worker/RecurringTransactionWorker.kt ---

kotlin
package com.kharcha.app.worker

import android.content.Context
import androidx.work.CoroutineWorker
import androidx.work.WorkerParameters
import com.kharcha.app.utils.RecurrenceHelper
import dagger.hilt.EntryPoint
import dagger.hilt.InstallIn
import dagger.hilt.android.EntryPointAccessors
import dagger.hilt.components.SingletonComponent

class RecurringTransactionWorker(
    context: Context,
    params: WorkerParameters
) : CoroutineWorker(context, params) {
    
    @EntryPoint
    @InstallIn(SingletonComponent::class)
    interface RecurrenceHelperEntryPoint {
        fun recurrenceHelper(): RecurrenceHelper
    }
    
    override suspend fun doWork(): Result {
        val appContext = applicationContext
        val hiltEntryPoint = EntryPointAccessors.fromApplication(
            appContext,
            RecurrenceHelperEntryPoint::class.java
        )
        
        val recurrenceHelper = hiltEntryPoint.recurrenceHelper()
        
        return try {
            recurrenceHelper.processRecurringTransactions()
            Result.success()
        } catch (e: Exception) {
            Result.retry()
        }
    }
}
--- FILE: app/src/main/java/com/kharcha/app/di/AppModule.kt ---

kotlin
package com.kharcha.app.di

import android.content.Context
import androidx.room.Room
import com.kharcha.app.data.dao.AccountDao
import com.kharcha.app.data.dao.AttachmentDao
import com.kharcha.app.data.dao.CategoryDao
import com.kharcha.app.data.dao.TransactionDao
import com.kharcha.app.data.db.KharchaDatabase
import dagger.Module
import dagger.Provides
import dagger.hilt.InstallIn
import dagger.hilt.android.qualifiers.ApplicationContext
import dagger.hilt.components.SingletonComponent
import javax.inject.Singleton

@Module
@InstallIn(SingletonComponent::class)
object AppModule {
    
    @Provides
    @Singleton
    fun provideDatabase(@ApplicationContext context: Context): KharchaDatabase {
        return Room.databaseBuilder(
            context,
            KharchaDatabase::class.java,
            "kharcha_database"
        )
            .fallbackToDestructiveMigration()
            .build()
    }
    
    @Provides
    fun provideTransactionDao(database: KharchaDatabase): TransactionDao =
        database.transactionDao()
    
    @Provides
    fun provideCategoryDao(database: KharchaDatabase): CategoryDao =
        database.categoryDao()
    
    @Provides
    fun provideAccountDao(database: KharchaDatabase): AccountDao =
        database.accountDao()
    
    @Provides
    fun provideAttachmentDao(database: KharchaDatabase): AttachmentDao =
        database.attachmentDao()
}
--- FILE: app/src/main/java/com/kharcha/app/ui/theme/Color.kt ---

kotlin
package com.kharcha.app.ui.theme

import androidx.compose.ui.graphics.Color

val Purple80 = Color(0xFFD0BCFF)
val PurpleGrey80 = Color(0xFFCCC2DC)
val Pink80 = Color(0xFFEFB8C8)

val Purple40 = Color(0xFF6650a4)
val PurpleGrey40 = Color(0xFF625b71)
val Pink40 = Color(0xFF7D5260)

val IncomeGreen = Color(0xFF4CAF50)
val ExpenseRed = Color(0xFFF44336)
--- FILE: app/src/main/java/com/kharcha/app/ui/theme/Theme.kt ---

kotlin
package com.kharcha.app.ui.theme

import androidx.compose.foundation.isSystemInDarkTheme
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.darkColorScheme
import androidx.compose.material3.lightColorScheme
import androidx.compose.runtime.Composable

private val DarkColorScheme = darkColorScheme(
    primary = Purple80,
    secondary = PurpleGrey80,
    tertiary = Pink80
)

private val LightColorScheme = lightColorScheme(
    primary = Purple40,
    secondary = PurpleGrey40,
    tertiary = Pink40
)

@Composable
fun KharchaTheme(
    darkTheme: Boolean = isSystemInDarkTheme(),
    content: @Composable () -> Unit
) {
    val colorScheme = if (darkTheme) DarkColorScheme else LightColorScheme

    MaterialTheme(
        colorScheme = colorScheme,
        typography = Typography,
        content = content
    )
}
--- FILE: app/src/main/java/com/kharcha/app/ui/theme/Type.kt ---

kotlin
package com.kharcha.app.ui.theme

import androidx.compose.material3.Typography
import androidx.compose.ui.text.TextStyle
import androidx.compose.ui.text.font.FontFamily
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.sp

val Typography = Typography(
    bodyLarge = TextStyle(
        fontFamily = FontFamily.Default,
        fontWeight = FontWeight.Normal,
        fontSize = 16.sp,
        lineHeight = 24.sp,
        letterSpacing = 0.5.sp
    )
)
--- FILE: app/src/main/java/com/kharcha/app/navigation/NavGraph.kt ---

kotlin
package com.kharcha.app.navigation

import androidx.compose.runtime.Composable
import androidx.compose.runtime.collectAsState
import androidx.compose.runtime.getValue
import androidx.hilt.navigation.compose.hiltViewModel
import androidx.navigation.NavType
import androidx.navigation.compose.NavHost
import androidx.navigation.compose.composable
import androidx.navigation.compose.rememberNavController
import androidx.navigation.navArgument
import com.kharcha.app.ui.screens.*
import com.kharcha.app.viewmodel.SettingsViewModel

@Composable
fun NavGraph() {
    val navController = rememberNavController()
    val settingsViewModel: SettingsViewModel = hiltViewModel()
    val isPinSet by settingsViewModel.isPinSet.collectAsState(initial = false)
    
    NavHost(
        navController = navController,
        startDestination = if (isPinSet) "pin_lock" else "home"
    ) {
        composable("pin_lock") {
            PinLockScreen(
                onUnlocked = { navController.navigate("home") {
                    popUpTo("pin_lock") { inclusive = true }
                }}
            )
        }
        
        composable("home") {
            HomeScreen(navController = navController)
        }
        
        composable("add_transaction") {
            AddTransactionScreen(navController = navController)
        }
        
        composable(
            route = "edit_transaction/{id}",
            arguments = listOf(navArgument("id") { type = NavType.LongType })
        ) { backStackEntry ->
            val id = backStackEntry.arguments?.getLong("id") ?: 0L
            AddTransactionScreen(navController = navController, transactionId = id)
        }
        
        composable("categories") {
            CategoriesScreen(navController = navController)
        }
        
        composable("reports") {
            ReportsScreen(navController = navController)
        }
        
        composable("settings") {
            SettingsScreen(navController = navController)
        }
        
        composable("receipt_scan") {
            ReceiptScanScreen(navController = navController)
        }
        
        composable("voice_input") {
            VoiceInputScreen(navController = navController)
        }
    }
}
--- FILE: app/src/main/java/com/kharcha/app/ui/screens/HomeScreen.kt ---

kotlin
package com.kharcha.app.ui.screens

import androidx.compose.foundation.clickable
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.items
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.*
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.dp
import androidx.hilt.navigation.compose.hiltViewModel
import androidx.navigation.NavController
import com.kharcha.app.data.model.TransactionEntity
import com.kharcha.app.data.model.TransactionType
import com.kharcha.app.ui.theme.ExpenseRed
import com.kharcha.app.ui.theme.IncomeGreen
import com.kharcha.app.viewmodel.TransactionViewModel
import java.time.format.DateTimeFormatter

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun HomeScreen(
    navController: NavController,
    viewModel: TransactionViewModel = hiltViewModel()
) {
    val transactions by viewModel.allTransactions.collectAsState(initial = emptyList())
    val searchQuery by viewModel.searchQuery.collectAsState()
    
    var showMenu by remember { mutableStateOf(false) }
    
    Scaffold(
        topBar = {
            TopAppBar(
                title = { Text("Kharcha") },
                actions = {
                    IconButton(onClick = { navController.navigate("categories") }) {
                        Icon(Icons.Default.Category, "Categories")
                    }
                    IconButton(onClick = { navController.navigate("reports") }) {
                        Icon(Icons.Default.BarChart, "Reports")
                    }
                    IconButton(onClick = { showMenu = true }) {
                        Icon(Icons.Default.MoreVert, "More")
                    }
                    DropdownMenu(expanded = showMenu, onDismissRequest = { showMenu = false }) {
                        DropdownMenuItem(
                            text = { Text("Scan Receipt") },
                            onClick = {
                                navController.navigate("receipt_scan")
                                showMenu = false
                            },
                            leadingIcon = { Icon(Icons.Default.CameraAlt, null) }
                        )
                        DropdownMenuItem(
                            text = { Text("Voice Input") },
                            onClick = {
                                navController.navigate("voice_input")
                                showMenu = false
                            },
                            leadingIcon = { Icon(Icons.Default.Mic, null) }
                        )
                        DropdownMenuItem(
                            text = { Text("Settings") },
                            onClick = {
                                navController.navigate("settings")
                                showMenu = false
                            },
                            leadingIcon = { Icon(Icons.Default.Settings, null) }
                        )
                    }
                }
            )
        },
        floatingActionButton = {
            FloatingActionButton(onClick = { navController.navigate("add_transaction") }) {
                Icon(Icons.Default.Add, "Add Transaction")
            }
        }
    ) { padding ->
        Column(
            modifier = Modifier
                .fillMaxSize()
                .padding(padding)
        ) {
            OutlinedTextField(
                value = searchQuery,
                onValueChange = { viewModel.setSearchQuery(it) },
                modifier = Modifier
                    .fillMaxWidth()
                    .padding(16.dp),
                placeholder = { Text("Search transactions...") },
                leadingIcon = { Icon(Icons.Default.Search, null) },
                trailingIcon = {
                    if (searchQuery.isNotEmpty()) {
                        IconButton(onClick = { viewModel.setSearchQuery("") }) {
                            Icon(Icons.Default.Clear, null)
                        }
                    }
                }
            )
            
            if (transactions.isEmpty()) {
                Box(
                    modifier = Modifier.fillMaxSize(),
                    contentAlignment = Alignment.Center
                ) {
                    Text("No transactions yet")
                }
            } else {
                LazyColumn(
                    contentPadding = PaddingValues(16.dp),
                    verticalArrangement = Arrangement.spacedBy(8.dp)
                ) {
                    items(transactions, key = { it.id }) { transaction ->
                        TransactionItem(
                            transaction = transaction,
                            onClick = { navController.navigate("edit_transaction/${transaction.id}") },
                            onDelete = { viewModel.deleteTransaction(transaction) }
                        )
                    }
                }
            }
        }
    }
}

@Composable
fun TransactionItem(
    transaction: TransactionEntity,
    onClick: () -> Unit,
    onDelete: () -> Unit
) {
    var showDeleteDialog by remember { mutableStateOf(false) }
    
    Card(
        modifier = Modifier
            .fillMaxWidth()
            .clickable(onClick = onClick)
    ) {
        Row(
            modifier = Modifier
                .fillMaxWidth()
                .padding(16.dp),
            horizontalArrangement = Arrangement.SpaceBetween,
            verticalAlignment = Alignment.CenterVertically
        ) {
            Column(modifier = Modifier.weight(1f)) {
                Text(
                    text = "Category #${transaction.categoryId}",
                    style = MaterialTheme.typography.titleMedium,
                    fontWeight = FontWeight.Bold
                )
                if (transaction.note.isNotEmpty()) {
                    Text(
                        text = transaction.note,
                        style = MaterialTheme.typography.bodySmall
                    )
                }
                Text(
                    text = transaction.date.format(DateTimeFormatter.ofPattern("dd MMM yyyy, hh:mm a")),
                    style = MaterialTheme.typography.bodySmall,
                    color = MaterialTheme.colorScheme.onSurfaceVariant
                )
            }
            
            Column(horizontalAlignment = Alignment.End) {
                Text(
                    text = "${transaction.currency} %.2f".format(transaction.amount),
                    style = MaterialTheme.typography.titleLarge,
                    fontWeight = FontWeight.Bold,
                    color = if (transaction.type == TransactionType.INCOME) IncomeGreen else ExpenseRed
                )
                IconButton(onClick = { showDeleteDialog = true }) {
                    Icon(Icons.Default.Delete, null, tint = MaterialTheme.colorScheme.error)
                }
            }
        }
    }
    
    if (showDeleteDialog) {
        AlertDialog(
            onDismissRequest = { showDeleteDialog = false },
            title = { Text("Delete Transaction") },
            text = { Text("Are you sure you want to delete this transaction?") },
            confirmButton = {
                TextButton(onClick = {
                    onDelete()
                    showDeleteDialog = false
                }) {
                    Text("Delete")
                }
            },
            dismissButton = {
                TextButton(onClick = { showDeleteDialog = false }) {
                    Text("Cancel")
                }
            }
        )
    }
}
--- FILE: app/src/main/java/com/kharcha/app/ui/screens/AddTransactionScreen.kt ---

kotlin
package com.kharcha.app.ui.screens

import androidx.compose.foundation.layout.*
import androidx.compose.foundation.rememberScrollState
import androidx.compose.foundation.text.KeyboardOptions
import androidx.compose.foundation.verticalScroll
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.ArrowBack
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Modifier
import androidx.compose.ui.text.input.KeyboardType
import androidx.compose.ui.unit.dp
import androidx.hilt.navigation.compose.hiltViewModel
import androidx.navigation.NavController
import com.kharcha.app.data.model.RecurrenceType
import com.kharcha.app.data.model.TransactionEntity
import com.kharcha.app.data.model.TransactionType
import com.kharcha.app.viewmodel.CategoryViewModel
import com.kharcha.app.viewmodel.TransactionViewModel
import kotlinx.coroutines.launch

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun AddTransactionScreen(
    navController: NavController,
    transactionId: Long? = null,
    transactionViewModel: TransactionViewModel = hiltViewModel(),
    categoryViewModel: CategoryViewModel = hiltViewModel()
) {
    val categories by categoryViewModel.categories.collectAsState(initial = emptyList())
    val scope = rememberCoroutineScope()
    
    var type by remember { mutableStateOf(TransactionType.EXPENSE) }
    var amount by remember { mutableStateOf("") }
    var selectedCategoryId by remember { mutableStateOf<Long?>(null) }
    var note by remember { mutableStateOf("") }
    var isRecurring by remember { mutableStateOf(false) }
    var recurrenceType by remember { mutableStateOf(RecurrenceType.MONTHLY) }
    
    var showCategoryMenu by remember { mutableStateOf(false) }
    var showRecurrenceMenu by remember { mutableStateOf(false) }
    
    LaunchedEffect(transactionId) {
        if (transactionId != null) {
            val transaction = transactionViewModel.getTransactionById(transactionId)
            transaction?.let {
                type = it.type
                amount = it.amount.toString()
                selectedCategoryId = it.categoryId
                note = it.note
                isRecurring = it.isRecurring
                recurrenceType = it.recurrenceType ?: RecurrenceType.MONTHLY
            }
        }
    }
    
    LaunchedEffect(categories) {
        if (selectedCategoryId == null && categories.isNotEmpty()) {
            selectedCategoryId = categories.first().id
        }
    }
    
    Scaffold(
        topBar = {
            TopAppBar(
                title = { Text(if (transactionId == null) "Add Transaction" else "Edit Transaction") },
                navigationIcon = {
                    IconButton(onClick = { navController.popBackStack() }) {
                        Icon(Icons.Default.ArrowBack, "Back")
                    }
                }
            )
        }
    ) { padding ->
        Column(
            modifier = Modifier
                .fillMaxSize()
                .padding(padding)
                .padding(16.dp)
                .verticalScroll(rememberScrollState()),
            verticalArrangement = Arrangement.spacedBy(16.dp)
        ) {
            Text("Transaction Type", style = MaterialTheme.typography.titleMedium)
            Row(horizontalArrangement = Arrangement.spacedBy(8.dp)) {
                FilterChip(
                    selected = type == TransactionType.EXPENSE,
                    onClick = { type = TransactionType.EXPENSE },
                    label = { Text("Expense") },
                    modifier = Modifier.weight(1f)
                )
                FilterChip(
                    selected = type == TransactionType.INCOME,
                    onClick = { type = TransactionType.INCOME },
                    label = { Text("Income") },
                    modifier = Modifier.weight(1f)
                )
            }
            
            OutlinedTextField(
                value = amount,
                onValueChange = { amount = it },
                label = { Text("Amount") },
                keyboardOptions = KeyboardOptions(keyboardType = KeyboardType.Decimal),
                modifier = Modifier.fillMaxWidth()
            )
            
            ExposedDropdownMenuBox(
                expanded = showCategoryMenu,
                onExpandedChange = { showCategoryMenu = it }
            ) {
                OutlinedTextField(
                    value = categories.find { it.id == selectedCategoryId }?.name ?: "",
                    onValueChange = {},
                    readOnly = true,
                    label = { Text("Category") },
                    trailingIcon = { ExposedDropdownMenuDefaults.TrailingIcon(expanded = showCategoryMenu) },
                    modifier = Modifier
                        .fillMaxWidth()
                        .menuAnchor()
                )
                ExposedDropdownMenu(
                    expanded = showCategoryMenu,
                    onDismissRequest = { showCategoryMenu = false }
                ) {
                    categories.forEach { category ->
                        DropdownMenuItem(
                            text = { Text(category.name) },
                            onClick = {
                                selectedCategoryId = category.id
                                showCategoryMenu = false
                            }
                        )
                    }
                }
            }
            
            OutlinedTextField(
                value = note,
                onValueChange = { note = it },
                label = { Text("Note (Optional)") },
                modifier = Modifier.fillMaxWidth(),
                maxLines = 3
            )
            
            Row(
                modifier = Modifier.fillMaxWidth(),
                horizontalArrangement = Arrangement.SpaceBetween
            ) {
                Text("Recurring", modifier = Modifier.align(androidx.compose.ui.Alignment.CenterVertically))
                Switch(checked = isRecurring, onCheckedChange = { isRecurring = it })
            }
            
            if (isRecurring) {
                ExposedDropdownMenuBox(
                    expanded = showRecurrenceMenu,
                    onExpandedChange = { showRecurrenceMenu = it }
                ) {
                    OutlinedTextField(
                        value = recurrenceType.name,
                        onValueChange = {},
                        readOnly = true,
                        label = { Text("Recurrence Type") },
                        trailingIcon = { ExposedDropdownMenuDefaults.TrailingIcon(expanded = showRecurrenceMenu) },
                        modifier = Modifier
                            .fillMaxWidth()
                            .menuAnchor()
                    )
                    ExposedDropdownMenu(
                        expanded = showRecurrenceMenu,
                        onDismissRequest = { showRecurrenceMenu = false }
                    ) {
                        RecurrenceType.values().forEach { type ->
                            DropdownMenuItem(
                                text = { Text(type.name) },
                                onClick = {
                                    recurrenceType = type
                                    showRecurrenceMenu = false
                                }
                            )
                        }
                    }
                }
            }
            
            Button(
                onClick = {
                    val amountValue = amount.toDoubleOrNull()
                    if (amountValue != null && amountValue > 0 && selectedCategoryId != null) {
                        scope.launch {
                            val transaction = TransactionEntity(
                                id = transactionId ?: 0,
                                type = type,
                                amount = amountValue,
                                categoryId = selectedCategoryId!!,
                                note = note,
                                isRecurring = isRecurring,
                                recurrenceType = if (isRecurring) recurrenceType else null
                            )
                            
                            if (transactionId == null) {
                                transactionViewModel.insertTransaction(transaction)
                            } else {
                                transactionViewModel.updateTransaction(transaction)
                            }
                            
                            navController.popBackStack()
                        }
                    }
                },
                modifier = Modifier.fillMaxWidth()
            ) {
                Text(if (transactionId == null) "Add" else "Update")
            }
        }
    }
}
--- FILE: app/src/main/java/com/kharcha/app/ui/screens/CategoriesScreen.kt ---

kotlin
package com.kharcha.app.ui.screens

import androidx.compose.foundation.layout.*
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.items
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.*
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.unit.dp
import androidx.hilt.navigation.compose.hiltViewModel
import androidx.navigation.NavController
import com.kharcha.app.data.model.CategoryEntity
import com.kharcha.app.data.model.TransactionType
import com.kharcha.app.viewmodel.CategoryViewModel
import kotlinx.coroutines.launch

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun CategoriesScreen(
    navController: NavController,
    viewModel: CategoryViewModel = hiltViewModel()
) {
    val categories by viewModel.categories.collectAsState(initial = emptyList())
    val scope = rememberCoroutineScope()
    
    var showAddDialog by remember { mutableStateOf(false) }
    var newCategoryName by remember { mutableStateOf("") }
    var newCategoryType by remember { mutableStateOf(TransactionType.EXPENSE) }
    
    Scaffold(
        topBar = {
            TopAppBar(
                title = { Text("Categories") },
                navigationIcon = {
                    IconButton(onClick = { navController.popBackStack() }) {
                        Icon(Icons.Default.ArrowBack, "Back")
                    }
                }
            )
        },
        floatingActionButton = {
            FloatingActionButton(onClick = { showAddDialog = true }) {
                Icon(Icons.Default.Add, "Add Category")
            }
        }
    ) { padding ->
        LazyColumn(
            modifier = Modifier
                .fillMaxSize()
                .padding(padding),
            contentPadding = PaddingValues(16.dp),
            verticalArrangement = Arrangement.spacedBy(8.dp)
        ) {
            items(categories, key = { it.id }) { category ->
                Card(modifier = Modifier.fillMaxWidth()) {
                    Row(
                        modifier = Modifier
                            .fillMaxWidth()
                            .padding(16.dp),
                        horizontalArrangement = Arrangement.SpaceBetween,
                        verticalAlignment = Alignment.CenterVertically
                    ) {
                        Column {
                            Text(category.name, style = MaterialTheme.typography.titleMedium)
                            Text(category.type.name, style = MaterialTheme.typography.bodySmall)
                        }
                        
                        if (!category.isDefault) {
                            IconButton(onClick = {
                                scope.launch { viewModel.deleteCategory(category) }
                            }) {
                                Icon(Icons.Default.Delete, null, tint = MaterialTheme.colorScheme.error)
                            }
                        }
                    }
                }
            }
        }
    }
    
    if (showAddDialog) {
        AlertDialog(
            onDismissRequest = { showAddDialog = false },
            title = { Text("Add Category") },
            text = {
                Column(verticalArrangement = Arrangement.spacedBy(8.dp)) {
                    OutlinedTextField(
                        value = newCategoryName,
                        onValueChange = { newCategoryName = it },
                        label = { Text("Category Name") }
                    )
                    Row(horizontalArrangement = Arrangement.spacedBy(8.dp)) {
                        FilterChip(
                            selected = newCategoryType == TransactionType.EXPENSE,
                            onClick = { newCategoryType = TransactionType.EXPENSE },
                            label = { Text("Expense") }
                        )
                        FilterChip(
                            selected = newCategoryType == TransactionType.INCOME,
                            onClick = { newCategoryType = TransactionType.INCOME },
                            label = { Text("Income") }
                        )
                    }
                }
            },
            confirmButton = {
                TextButton(onClick = {
                    if (newCategoryName.isNotBlank()) {
                        scope.launch {
                            viewModel.addCategory(newCategoryName.trim(), newCategoryType)
                            newCategoryName = ""
                            showAddDialog = false
                        }
                    }
                }) {
                    Text("Add")
                }
            },
            dismissButton = {
                TextButton(onClick = {
                    newCategoryName = ""
                    showAddDialog = false
                }) {
                    Text("Cancel")
                }
            }
        )
    }
}
--- FILE: app/src/main/java/com/kharcha/app/ui/screens/ReportsScreen.kt ---

kotlin
package com.kharcha.app.ui.screens

import androidx.compose.foundation.layout.*
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.ArrowBack
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Modifier
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.dp
import androidx.hilt.navigation.compose.hiltViewModel
import androidx.navigation.NavController
import com.kharcha.app.data.model.TransactionType
import com.kharcha.app.ui.theme.ExpenseRed
import com.kharcha.app.ui.theme.IncomeGreen
import com.kharcha.app.viewmodel.TransactionViewModel
import com.patrykandpatrick.vico.compose.axis.horizontal.rememberBottomAxis
import com.patrykandpatrick.vico.compose.axis.vertical.rememberStartAxis
import com.patrykandpatrick.vico.compose.chart.Chart
import com.patrykandpatrick.vico.compose.chart.column.columnChart
import com.patrykandpatrick.vico.core.entry.entryModelOf
import java.time.LocalDateTime
import java.time.YearMonth

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun ReportsScreen(
    navController: NavController,
    viewModel: TransactionViewModel = hiltViewModel()
) {
    val transactions by viewModel.allTransactions.collectAsState(initial = emptyList())
    
    val monthlyData = remember(transactions) {
        val now = YearMonth.now()
        val last6Months = (0..5).map { now.minusMonths(it.toLong()) }.reversed()
        
        last6Months.map { month ->
            val monthTransactions = transactions.filter {
                YearMonth.from(it.date) == month
            }
            val income = monthTransactions.filter { it.type == TransactionType.INCOME }.sumOf { it.amount }
            val expense = monthTransactions.filter { it.type == TransactionType.EXPENSE }.sumOf { it.amount }
            Triple(month.toString(), income, expense)
        }
    }
    
    Scaffold(
        topBar = {
            TopAppBar(
                title = { Text("Reports") },
                navigationIcon = {
                    IconButton(onClick = { navController.popBackStack() }) {
                        Icon(Icons.Default.ArrowBack, "Back")
                    }
                }
            )
        }
    ) { padding ->
        LazyColumn(
            modifier = Modifier
                .fillMaxSize()
                .padding(padding)
                .padding(16.dp),
            verticalArrangement = Arrangement.spacedBy(16.dp)
        ) {
            item {
                Text("Monthly Overview", style = MaterialTheme.typography.headlineSmall)
            }
            
            item {
                val currentMonth = transactions.filter {
                    YearMonth.from(it.date) == YearMonth.now()
                }
                val totalIncome = currentMonth.filter { it.type == TransactionType.INCOME }.sumOf { it.amount }
                val totalExpense = currentMonth.filter { it.type == TransactionType.EXPENSE }.sumOf { it.amount }
                
                Row(modifier = Modifier.fillMaxWidth(), horizontalArrangement = Arrangement.spacedBy(16.dp)) {
                    Card(modifier = Modifier.weight(1f)) {
                        Column(modifier = Modifier.padding(16.dp)) {
                            Text("Income", style = MaterialTheme.typography.titleMedium)
                            Text(
                                " %.2f".format(totalIncome),
                                style = MaterialTheme.typography.headlineMedium,
                                fontWeight = FontWeight.Bold,
                                color = IncomeGreen
                            )
                        }
                    }
                    Card(modifier = Modifier.weight(1f)) {
                        Column(modifier = Modifier.padding(16.dp)) {
                            Text("Expense", style = MaterialTheme.typography.titleMedium)
                            Text(
                                " %.2f".format(totalExpense),
                                style = MaterialTheme.typography.headlineMedium,
                                fontWeight = FontWeight.Bold,
                                color = ExpenseRed
                            )
                        }
                    }
                }
            }
            
            item {
                Card(modifier = Modifier.fillMaxWidth()) {
                    Column(modifier = Modifier.padding(16.dp)) {
                        Text("Last 6 Months", style = MaterialTheme.typography.titleMedium)
                        Spacer(modifier = Modifier.height(16.dp))
                        
                        if (monthlyData.isNotEmpty()) {
                            val chartEntryModel = entryModelOf(
                                *monthlyData.mapIndexed { index, data ->
                                    index to data.third.toFloat()
                                }.toTypedArray()
                            )
                            
                            Chart(
                                chart = columnChart(),
                                model = chartEntryModel,
                                startAxis = rememberStartAxis(),
                                bottomAxis = rememberBottomAxis(),
                                modifier = Modifier
                                    .fillMaxWidth()
                                    .height(200.dp)
                            )
                        }
                    }
                }
            }
        }
    }
}
--- FILE: app/src/main/java/com/kharcha/app/ui/screens/SettingsScreen.kt ---

kotlin
package com.kharcha.app.ui.screens

import android.Manifest
import android.content.pm.PackageManager
import androidx.activity.compose.rememberLauncherForActivityResult
import androidx.activity.result.contract.ActivityResultContracts
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.rememberScrollState
import androidx.compose.foundation.verticalScroll
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.ArrowBack
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Modifier
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.unit.dp
import androidx.core.content.ContextCompat
import androidx.hilt.navigation.compose.hiltViewModel
import androidx.navigation.NavController
import com.kharcha.app.viewmodel.SettingsViewModel
import kotlinx.coroutines.launch

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun SettingsScreen(
    navController: NavController,
    viewModel: SettingsViewModel = hiltViewModel()
) {
    val context = LocalContext.current
    val scope = rememberCoroutineScope()
    
    val currency by viewModel.currency.collectAsState(initial = "INR")
    val smsAutoParseEnabled by viewModel.smsAutoParseEnabled.collectAsState(initial = false)
    val biometricEnabled by viewModel.biometricEnabled.collectAsState(initial = false)
    
    var showCurrencyDialog by remember { mutableStateOf(false) }
    var showSetPinDialog by remember { mutableStateOf(false) }
    
    val smsPermissionLauncher = rememberLauncherForActivityResult(
        ActivityResultContracts.RequestMultiplePermissions()
    ) { permissions ->
        val allGranted = permissions.values.all { it }
        if (allGranted) {
            scope.launch { viewModel.setSmsAutoParseEnabled(true) }
        }
    }
    
    val exportCsvLauncher = rememberLauncherForActivityResult(
        ActivityResultContracts.CreateDocument("text/csv")
    ) { uri ->
        uri?.let { scope.launch { viewModel.exportToCsv(it) } }
    }
    
    val exportJsonLauncher = rememberLauncherForActivityResult(
        ActivityResultContracts.CreateDocument("application/json")
    ) { uri ->
        uri?.let { scope.launch { viewModel.exportToJson(it) } }
    }
    
    val exportXlsxLauncher = rememberLauncherForActivityResult(
        ActivityResultContracts.CreateDocument("application/vnd.openxmlformats-officedocument.spreadsheetml.sheet")
    ) { uri ->
        uri?.let { scope.launch { viewModel.exportToXlsx(it) } }
    }
    
    val importLauncher = rememberLauncherForActivityResult(
        ActivityResultContracts.GetContent()
    ) { uri ->
        uri?.let { scope.launch { viewModel.importData(it) } }
    }
    
    Scaffold(
        topBar = {
            TopAppBar(
                title = { Text("Settings") },
                navigationIcon = {
                    IconButton(onClick = { navController.popBackStack() }) {
                        Icon(Icons.Default.ArrowBack, "Back")
                    }
                }
            )
        }
    ) { padding ->
        Column(
            modifier = Modifier
                .fillMaxSize()
                .padding(padding)
                .verticalScroll(rememberScrollState())
        ) {
            Text(
                "General",
                style = MaterialTheme.typography.titleMedium,
                modifier = Modifier.padding(16.dp)
            )
            
            ListItem(
                headlineContent = { Text("Currency") },
                supportingContent = { Text(currency) },
                trailingContent = {
                    TextButton(onClick = { showCurrencyDialog = true }) {
                        Text("Change")
                    }
                }
            )
            
            HorizontalDivider()
            
            Text(
                "Security",
                style = MaterialTheme.typography.titleMedium,
                modifier = Modifier.padding(16.dp)
            )
            
            ListItem(
                headlineContent = { Text("PIN Lock") },
                trailingContent = {
                    TextButton(onClick = { showSetPinDialog = true }) {
                        Text("Set PIN")
                    }
                }
            )
            
            ListItem(
                headlineContent = { Text("Biometric Authentication") },
                trailingContent = {
                    Switch(
                        checked = biometricEnabled,
                        onCheckedChange = { scope.launch { viewModel.setBiometricEnabled(it) } }
                    )
                }
            )
            
            HorizontalDivider()
            
            Text(
                "Auto-Import",
                style = MaterialTheme.typography.titleMedium,
                modifier = Modifier.padding(16.dp)
            )
            
            ListItem(
                headlineContent = { Text("SMS Auto-Parse") },
                supportingContent = { Text("Automatically detect transactions from SMS") },
                trailingContent = {
                    Switch(
                        checked = smsAutoParseEnabled,
                        onCheckedChange = { enabled ->
                            if (enabled) {
                                val hasPermissions = ContextCompat.checkSelfPermission(
                                    context,
                                    Manifest.permission.RECEIVE_SMS
                                ) == PackageManager.PERMISSION_GRANTED
                                
                                if (hasPermissions) {
                                    scope.launch { viewModel.setSmsAutoParseEnabled(true) }
                                } else {
                                    smsPermissionLauncher.launch(
                                        arrayOf(
                                            Manifest.permission.RECEIVE_SMS,
                                            Manifest.permission.READ_SMS
                                        )
                                    )
                                }
                            } else {
                                scope.launch { viewModel.setSmsAutoParseEnabled(false) }
                            }
                        }
                    )
                }
            )
            
            HorizontalDivider()
            
            Text(
                "Data Management",
                style = MaterialTheme.typography.titleMedium,
                modifier = Modifier.padding(16.dp)
            )
            
            ListItem(
                headlineContent = { Text("Export to CSV") },
                trailingContent = {
                    TextButton(onClick = { exportCsvLauncher.launch("kharcha_export.csv") }) {
                        Text("Export")
                    }
                }
            )
            
            ListItem(
                headlineContent = { Text("Export to JSON") },
                trailingContent = {
                    TextButton(onClick = { exportJsonLauncher.launch("kharcha_backup.json") }) {
                        Text("Export")
                    }
                }
            )
            
            ListItem(
                headlineContent = { Text("Export to Excel") },
                trailingContent = {
                    TextButton(onClick = { exportXlsxLauncher.launch("kharcha_export.xlsx") }) {
                        Text("Export")
                    }
                }
            )
            
            ListItem(
                headlineContent = { Text("Import Data") },
                supportingContent = { Text("Import from CSV, JSON, or Excel") },
                trailingContent = {
                    TextButton(onClick = { importLauncher.launch("*/*") }) {
                        Text("Import")
                    }
                }
            )
        }
    }
    
    if (showCurrencyDialog) {
        var tempCurrency by remember { mutableStateOf(currency) }
        AlertDialog(
            onDismissRequest = { showCurrencyDialog = false },
            title = { Text("Set Currency") },
            text = {
                OutlinedTextField(
                    value = tempCurrency,
                    onValueChange = { tempCurrency = it },
                    label = { Text("Currency Code") }
                )
            },
            confirmButton = {
                TextButton(onClick = {
                    scope.launch {
                        viewModel.setCurrency(tempCurrency)
                        showCurrencyDialog = false
                    }
                }) {
                    Text("Save")
                }
            },
            dismissButton = {
                TextButton(onClick = { showCurrencyDialog = false }) {
                    Text("Cancel")
                }
            }
        )
    }
    
    if (showSetPinDialog) {
        var pin by remember { mutableStateOf("") }
        var confirmPin by remember { mutableStateOf("") }
        var error by remember { mutableStateOf("") }
        
        AlertDialog(
            onDismissRequest = { showSetPinDialog = false },
            title = { Text("Set PIN") },
            text = {
                Column(verticalArrangement = Arrangement.spacedBy(8.dp)) {
                    OutlinedTextField(
                        value = pin,
                        onValueChange = {
                            if (it.length <= 4 && it.all { char -> char.isDigit() }) {
                                pin = it
                                error = ""
                            }
                        },
                        label = { Text("4-digit PIN") },
                        isError = error.isNotEmpty()
                    )
                    OutlinedTextField(
                        value = confirmPin,
                        onValueChange = {
                            if (it.length <= 4 && it.all { char -> char.isDigit() }) {
                                confirmPin = it
                                error = ""
                            }
                        },
                        label = { Text("Confirm PIN") },
                        isError = error.isNotEmpty()
                    )
                    if (error.isNotEmpty()) {
                        Text(error, color = MaterialTheme.colorScheme.error, style = MaterialTheme.typography.bodySmall)
                    }
                }
            },
            confirmButton = {
                TextButton(onClick = {
                    when {
                        pin.length != 4 -> error = "PIN must be 4 digits"
                        pin != confirmPin -> error = "PINs do not match"
                        else -> {
                            scope.launch {
                                viewModel.setPin(pin)
                                showSetPinDialog = false
                            }
                        }
                    }
                }) {
                    Text("Save")
                }
            },
            dismissButton = {
                TextButton(onClick = { showSetPinDialog = false }) {
                    Text("Cancel")
                }
            }
        )
    }
}
--- FILE: app/src/main/java/com/kharcha/app/ui/screens/PinLockScreen.kt ---

kotlin
package com.kharcha.app.ui.screens

import androidx.compose.foundation.layout.*
import androidx.compose.foundation.text.KeyboardOptions
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.text.input.KeyboardType
import androidx.compose.ui.text.input.PasswordVisualTransformation
import androidx.compose.ui.unit.dp
import androidx.hilt.navigation.compose.hiltViewModel
import com.kharcha.app.viewmodel.SettingsViewModel
import kotlinx.coroutines.launch

@Composable
fun PinLockScreen(
    onUnlocked: () -> Unit,
    viewModel: SettingsViewModel = hiltViewModel()
) {
    var pin by remember { mutableStateOf("") }
    var error by remember { mutableStateOf(false) }
    val scope = rememberCoroutineScope()
    
    Box(
        modifier = Modifier.fillMaxSize(),
        contentAlignment = Alignment.Center
    ) {
        Column(
            horizontalAlignment = Alignment.CenterHorizontally,
            verticalArrangement = Arrangement.spacedBy(16.dp),
            modifier = Modifier.padding(32.dp)
        ) {
            Text("Enter PIN", style = MaterialTheme.typography.headlineMedium)
            
            OutlinedTextField(
                value = pin,
                onValueChange = {
                    if (it.length <= 4 && it.all { char -> char.isDigit() }) {
                        pin = it
                        error = false
                        
                        if (it.length == 4) {
                            scope.launch {
                                val valid = viewModel.verifyPin(it)
                                if (valid) {
                                    onUnlocked()
                                } else {
                                    error = true
                                    pin = ""
                                }
                            }
                        }
                    }
                },
                label = { Text("PIN") },
                visualTransformation = PasswordVisualTransformation(),
                keyboardOptions = KeyboardOptions(keyboardType = KeyboardType.NumberPassword),
                isError = error,
                supportingText = {
                    if (error) {
                        Text("Incorrect PIN", color = MaterialTheme.colorScheme.error)
                    }
                }
            )
        }
    }
}
--- FILE: app/src/main/java/com/kharcha/app/ui/screens/ReceiptScanScreen.kt ---

kotlin
package com.kharcha.app.ui.screens

import android.Manifest
import android.content.pm.PackageManager
import android.graphics.Bitmap
import androidx.activity.compose.rememberLauncherForActivityResult
import androidx.activity.result.contract.ActivityResultContracts
import androidx.camera.core.ImageCapture
import androidx.camera.core.ImageCaptureException
import androidx.camera.core.ImageProxy
import androidx.compose.foundation.layout.*
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.ArrowBack
import androidx.compose.material.icons.filled.Camera
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.unit.dp
import androidx.core.content.ContextCompat
import androidx.hilt.navigation.compose.hiltViewModel
import androidx.navigation.NavController
import com.kharcha.app.viewmodel.ReceiptScanViewModel
import kotlinx.coroutines.launch
import java.util.concurrent.Executor

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun ReceiptScanScreen(
    navController: NavController,
    viewModel: ReceiptScanViewModel = hiltViewModel()
) {
    val context = LocalContext.current
    val scope = rememberCoroutineScope()
    
    var hasCameraPermission by remember {
        mutableStateOf(
            ContextCompat.checkSelfPermission(
                context,
                Manifest.permission.CAMERA
            ) == PackageManager.PERMISSION_GRANTED
        )
    }
    
    val permissionLauncher = rememberLauncherForActivityResult(
        ActivityResultContracts.RequestPermission()
    ) { isGranted ->
        hasCameraPermission = isGranted
    }
    
    val receiptData by viewModel.receiptData.collectAsState()
    val isScanning by viewModel.isScanning.collectAsState()
    
    LaunchedEffect(Unit) {
        if (!hasCameraPermission) {
            permissionLauncher.launch(Manifest.permission.CAMERA)
        }
    }
    
    Scaffold(
        topBar = {
            TopAppBar(
                title = { Text("Scan Receipt") },
                navigationIcon = {
                    IconButton(onClick = { navController.popBackStack() }) {
                        Icon(Icons.Default.ArrowBack, "Back")
                    }
                }
            )
        }
    ) { padding ->
        Column(
            modifier = Modifier
                .fillMaxSize()
                .padding(padding)
                .padding(16.dp),
            horizontalAlignment = Alignment.CenterHorizontally,
            verticalArrangement = Arrangement.Center
        ) {
            if (!hasCameraPermission) {
                Text("Camera permission required")
                Button(onClick = { permissionLauncher.launch(Manifest.permission.CAMERA) }) {
                    Text("Grant Permission")
                }
            } else {
                Text("Receipt scanning feature", style = MaterialTheme.typography.titleLarge)
                Spacer(modifier = Modifier.height(16.dp))
                
                if (isScanning) {
                    CircularProgressIndicator()
                } else {
                    receiptData?.let { data ->
                        Card(modifier = Modifier.fillMaxWidth()) {
                            Column(modifier = Modifier.padding(16.dp)) {
                                Text("Scanned Data:", style = MaterialTheme.typography.titleMedium)
                                Spacer(modifier = Modifier.height(8.dp))
                                data.amount?.let { Text("Amount: $it") }
                                data.date?.let { Text("Date: $it") }
                                data.merchant?.let { Text("Merchant: $it") }
                            }
                        }
                    } ?: run {
                        Text("Point camera at receipt and tap capture")
                    }
                }
                
                Spacer(modifier = Modifier.height(32.dp))
                
                Button(
                    onClick = {
                        // Mock scan for now - in real implementation, capture from camera
                        scope.launch {
                            viewModel.scanMockReceipt()
                        }
                    },
                    enabled = !isScanning
                ) {
                    Icon(Icons.Default.Camera, null)
                    Spacer(modifier = Modifier.width(8.dp))
                    Text("Capture (Mock)")
                }
            }
        }
    }
}
--- FILE: app/src/main/java/com/kharcha/app/ui/screens/VoiceInputScreen.kt ---

kotlin
package com.kharcha.app.ui.screens

import android.Manifest
import android.content.Intent
import android.content.pm.PackageManager
import android.speech.RecognizerIntent
import androidx.activity.compose.rememberLauncherForActivityResult
import androidx.activity.result.contract.ActivityResultContracts
import androidx.compose.foundation.layout.*
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.ArrowBack
import androidx.compose.material.icons.filled.Mic
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.unit.dp
import androidx.core.content.ContextCompat
import androidx.hilt.navigation.compose.hiltViewModel
import androidx.navigation.NavController
import com.kharcha.app.viewmodel.VoiceInputViewModel
import kotlinx.coroutines.launch

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun VoiceInputScreen(
    navController: NavController,
    viewModel: VoiceInputViewModel = hiltViewModel()
) {
    val context = LocalContext.current
    val scope = rememberCoroutineScope()
    
    var hasAudioPermission by remember {
        mutableStateOf(
            ContextCompat.checkSelfPermission(
                context,
                Manifest.permission.RECORD_AUDIO
            ) == PackageManager.PERMISSION_GRANTED
        )
    }
    
    val permissionLauncher = rememberLauncherForActivityResult(
        ActivityResultContracts.RequestPermission()
    ) { isGranted ->
        hasAudioPermission = isGranted
    }
    
    val speechLauncher = rememberLauncherForActivityResult(
        ActivityResultContracts.StartActivityForResult()
    ) { result ->
        result.data?.getStringArrayListExtra(RecognizerIntent.EXTRA_RESULTS)?.firstOrNull()?.let { text ->
            scope.launch {
                viewModel.parseVoiceInput(text)
            }
        }
    }
    
    val voiceData by viewModel.voiceTransactionData.collectAsState()
    
    Scaffold(
        topBar = {
            TopAppBar(
                title = { Text("Voice Input") },
                navigationIcon = {
                    IconButton(onClick = { navController.popBackStack() }) {
                        Icon(Icons.Default.ArrowBack, "Back")
                    }
                }
            )
        }
    ) { padding ->
        Column(
            modifier = Modifier
                .fillMaxSize()
                .padding(padding)
                .padding(16.dp),
            horizontalAlignment = Alignment.CenterHorizontally,
            verticalArrangement = Arrangement.Center
        ) {
            if (!hasAudioPermission) {
                Text("Microphone permission required")
                Button(onClick = { permissionLauncher.launch(Manifest.permission.RECORD_AUDIO) }) {
                    Text("Grant Permission")
                }
            } else {
                Text("Voice input feature", style = MaterialTheme.typography.titleLarge)
                Spacer(modifier = Modifier.height(16.dp))
                
                voiceData?.let { data ->
                    Card(modifier = Modifier.fillMaxWidth()) {
                        Column(modifier = Modifier.padding(16.dp)) {
                            Text("Parsed Data:", style = MaterialTheme.typography.titleMedium)
                            Spacer(modifier = Modifier.height(8.dp))
                            Text("Type: ${data.type}")
                            data.amount?.let { Text("Amount: $it") }
                            Text("Category: ${data.category}")
                            Text("Note: ${data.note}")
                        }
                    }
                    
                    Spacer(modifier = Modifier.height(16.dp))
                    
                    Button(
                        onClick = {
                            scope.launch {
                                viewModel.saveTransaction()
                                navController.popBackStack()
                            }
                        },
                        modifier = Modifier.fillMaxWidth()
                    ) {
                        Text("Save Transaction")
                    }
                } ?: run {
                    Text("Tap the microphone to speak")
                }
                
                Spacer(modifier = Modifier.height(32.dp))
                
                FloatingActionButton(
                    onClick = {
                        val intent = Intent(RecognizerIntent.ACTION_RECOGNIZE_SPEECH).apply {
                            putExtra(
                                RecognizerIntent.EXTRA_LANGUAGE_MODEL,
                                RecognizerIntent.LANGUAGE_MODEL_FREE_FORM
                            )
                            putExtra(RecognizerIntent.EXTRA_PROMPT, "Say your transaction")
                        }
                        speechLauncher.launch(intent)
                    }
                ) {
                    Icon(Icons.Default.Mic, "Start Voice Input")
                }
            }
        }
    }
}
--- FILE: app/src/main/java/com/kharcha/app/viewmodel/TransactionViewModel.kt ---

kotlin
package com.kharcha.app.viewmodel

import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.kharcha.app.data.model.TransactionEntity
import com.kharcha.app.data.repository.TransactionRepository
import dagger.hilt.android.lifecycle.HiltViewModel
import kotlinx.coroutines.flow.*
import kotlinx.coroutines.launch
import javax.inject.Inject

@HiltViewModel
class TransactionViewModel @Inject constructor(
    private val repository: TransactionRepository
) : ViewModel() {
    
    private val _searchQuery = MutableStateFlow("")
    val searchQuery: StateFlow<String> = _searchQuery.asStateFlow()
    
    val allTransactions: StateFlow<List<TransactionEntity>> = _searchQuery
        .flatMapLatest { query ->
            if (query.isEmpty()) {
                repository.getAllTransactions()
            } else {
                repository.searchTransactions(query)
            }
        }
        .stateIn(viewModelScope, SharingStarted.Lazily, emptyList())
    
    fun setSearchQuery(query: String) {
        _searchQuery.value = query
    }
    
    fun insertTransaction(transaction: TransactionEntity) {
        viewModelScope.launch {
            repository.insert(transaction)
        }
    }
    
    fun updateTransaction(transaction: TransactionEntity) {
        viewModelScope.launch {
            repository.update(transaction)
        }
    }
    
    fun deleteTransaction(transaction: TransactionEntity) {
        viewModelScope.launch {
            repository.delete(transaction)
        }
    }
    
    suspend fun getTransactionById(id: Long): TransactionEntity? {
        return repository.getById(id)
    }
}
--- FILE: app/src/main/java/com/kharcha/app/viewmodel/CategoryViewModel.kt ---

kotlin
package com.kharcha.app.viewmodel

import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.kharcha.app.data.model.CategoryEntity
import com.kharcha.app.data.model.TransactionType
import com.kharcha.app.data.repository.CategoryRepository
import dagger.hilt.android.lifecycle.HiltViewModel
import kotlinx.coroutines.flow.SharingStarted
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.stateIn
import kotlinx.coroutines.launch
import javax.inject.Inject

@HiltViewModel
class CategoryViewModel @Inject constructor(
    private val repository: CategoryRepository
) : ViewModel() {
    
    val categories: StateFlow<List<CategoryEntity>> = repository.getAllCategories()
        .stateIn(viewModelScope, SharingStarted.Lazily, emptyList())
    
    init {
        viewModelScope.launch {
            initializeDefaultCategories()
        }
    }
    
    private suspend fun initializeDefaultCategories() {
        val expenseCategories = listOf("Food", "Transport", "Shopping", "Entertainment", "Bills", "Health")
        val incomeCategories = listOf("Salary", "Business", "Investment", "Gift")
        
        expenseCategories.forEach { name ->
            if (repository.findByNameAndType(name, TransactionType.EXPENSE) == null) {
                repository.insert(CategoryEntity(name = name, type = TransactionType.EXPENSE, isDefault = true))
            }
        }
        
        incomeCategories.forEach { name ->
            if (repository.findByNameAndType(name, TransactionType.INCOME) == null) {
                repository.insert(CategoryEntity(name = name, type = TransactionType.INCOME, isDefault = true))
            }
        }
    }
    
    suspend fun addCategory(name: String, type: TransactionType) {
        repository.insert(CategoryEntity(name = name, type = type))
    }
    
    suspend fun deleteCategory(category: CategoryEntity) {
        repository.delete(category)
    }
}
--- FILE: app/src/main/java/com/kharcha/app/viewmodel/SettingsViewModel.kt ---

kotlin
package com.kharcha.app.viewmodel

import android.net.Uri
import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.kharcha.app.data.datastore.SettingsDataStore
import com.kharcha.app.importexport.ExportManager
import com.kharcha.app.importexport.ImportManager
import com.kharcha.app.security.PinManager
import dagger.hilt.android.lifecycle.HiltViewModel
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.map
import kotlinx.coroutines.launch
import javax.inject.Inject

@HiltViewModel
class SettingsViewModel @Inject constructor(
    private val settingsDataStore: SettingsDataStore,
    private val pinManager: PinManager,
    private val exportManager: ExportManager,
    private val importManager: ImportManager
) : ViewModel() {
    
    val currency: Flow<String> = settingsDataStore.currency
    val biometricEnabled: Flow<Boolean> = settingsDataStore.biometricEnabled
    val smsAutoParseEnabled: Flow<Boolean> = settingsDataStore.smsAutoParseEnabled
    val isPinSet: Flow<Boolean> = settingsDataStore.pinHash.map { it != null }
    
    fun setCurrency(currency: String) {
        viewModelScope.launch {
            settingsDataStore.setCurrency(currency)
        }
    }
    
    fun setBiometricEnabled(enabled: Boolean) {
        viewModelScope.launch {
            settingsDataStore.setBiometricEnabled(enabled)
        }
    }
    
    fun setSmsAutoParseEnabled(enabled: Boolean) {
        viewModelScope.launch {
            settingsDataStore.setSmsAutoParseEnabled(enabled)
        }
    }
    
    fun setPin(pin: String) {
        viewModelScope.launch {
            pinManager.setPin(pin)
        }
    }
    
    suspend fun verifyPin(pin: String): Boolean {
        return pinManager.verifyPin(pin)
    }
    
    suspend fun exportToCsv(uri: Uri) {
        exportManager.exportToCsv(uri)
    }
    
    suspend fun exportToJson(uri: Uri) {
        exportManager.exportToJson(uri)
    }
    
    suspend fun exportToXlsx(uri: Uri) {
        exportManager.exportToXlsx(uri)
    }
    
    suspend fun importData(uri: Uri) {
        val mimeType = uri.toString()
        when {
            mimeType.endsWith(".csv") -> importManager.importFromCsv(uri)
            mimeType.endsWith(".json") -> importManager.importFromJson(uri)
            mimeType.endsWith(".xlsx") -> importManager.importFromXlsx(uri)
            else -> {
                // Try JSON as fallback
                importManager.importFromJson(uri)
            }
        }
    }
}
--- FILE: app/src/main/java/com/kharcha/app/viewmodel/ReceiptScanViewModel.kt ---

kotlin
package com.kharcha.app.viewmodel

import android.graphics.Bitmap
import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.kharcha.app.ocr.ReceiptData
import com.kharcha.app.ocr.ReceiptScanner
import dagger.hilt.android.lifecycle.HiltViewModel
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.asStateFlow
import kotlinx.coroutines.launch
import java.time.LocalDate
import javax.inject.Inject

@HiltViewModel
class ReceiptScanViewModel @Inject constructor(
    private val receiptScanner: ReceiptScanner
) : ViewModel() {
    
    private val _receiptData = MutableStateFlow<ReceiptData?>(null)
    val receiptData: StateFlow<ReceiptData?> = _receiptData.asStateFlow()
    
    private val _isScanning = MutableStateFlow(false)
    val isScanning: StateFlow<Boolean> = _isScanning.asStateFlow()
    
    fun scanReceipt(bitmap: Bitmap) {
        viewModelScope.launch {
            _isScanning.value = true
            try {
                val data = receiptScanner.scanReceipt(bitmap)
                _receiptData.value = data
            } finally {
                _isScanning.value = false
            }
        }
    }
    
    fun scanMockReceipt() {
        viewModelScope.launch {
            _isScanning.value = true
            kotlinx.coroutines.delay(1000)
            _receiptData.value = ReceiptData(
                amount = 450.50,
                date = LocalDate.now(),
                merchant = "Sample Store",
                rawText = "Mock receipt scan"
            )
            _isScanning.value = false
        }
    }
}
--- FILE: app/src/main/java/com/kharcha/app/viewmodel/VoiceInputViewModel.kt ---

kotlin
package com.kharcha.app.viewmodel

import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.kharcha.app.data.model.CategoryEntity
import com.kharcha.app.data.model.TransactionEntity
import com.kharcha.app.data.repository.CategoryRepository
import com.kharcha.app.data.repository.TransactionRepository
import com.kharcha.app.voice.VoiceInputParser
import com.kharcha.app.voice.VoiceTransactionData
import dagger.hilt.android.lifecycle.HiltViewModel
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.asStateFlow
import kotlinx.coroutines.launch
import javax.inject.Inject

@HiltViewModel
class VoiceInputViewModel @Inject constructor(
    private val voiceInputParser: VoiceInputParser,
    private val transactionRepository: TransactionRepository,
    private val categoryRepository: CategoryRepository
) : ViewModel() {
    
    private val _voiceTransactionData = MutableStateFlow<VoiceTransactionData?>(null)
    val voiceTransactionData: StateFlow<VoiceTransactionData?> = _voiceTransactionData.asStateFlow()
    
    fun parseVoiceInput(text: String) {
        viewModelScope.launch {
            val data = voiceInputParser.parseVoiceInput(text)
            _voiceTransactionData.value = data
        }
    }
    
    suspend fun saveTransaction() {
        val data = _voiceTransactionData.value ?: return
        
        var category = categoryRepository.findByNameAndType(data.category, data.type)
        if (category == null) {
            val categoryId = categoryRepository.insert(CategoryEntity(name = data.category, type = data.type))
            category = categoryRepository.getById(categoryId)
        }
        
        val transaction = TransactionEntity(
            type = data.type,
            amount = data.amount ?: 0.0,
            categoryId = category?.id ?: 1,
            note = data.note,
            date = data.date
        )
        
        transactionRepository.insert(transaction)
    }
}
--- FILE: app/src/test/java/com/kharcha/app/RecurrenceHelperTest.kt ---

kotlin
package com.kharcha.app

import com.kharcha.app.data.model.RecurrenceType
import com.kharcha.app.utils.RecurrenceHelper
import io.mockk.mockk
import org.junit.Assert.assertEquals
import org.junit.Test
import java.time.LocalDate

class RecurrenceHelperTest {
    
    private val recurrenceHelper = RecurrenceHelper(mockk(relaxed = true))
    
    @Test
    fun testMonthlyRecurrence_normalMonth() {
        val date = LocalDate.of(2024, 1, 15)
        val next = recurrenceHelper.calculateNextDate(date, RecurrenceType.MONTHLY)
        assertEquals(LocalDate.of(2024, 2, 15), next)
    }
    
    @Test
    fun testMonthlyRecurrence_endOfMonth() {
        val date = LocalDate.of(2024, 1, 31)
        val next = recurrenceHelper.calculateNextDate(date, RecurrenceType.MONTHLY)
        assertEquals(LocalDate.of(2024, 2, 29), next)
    }
    
    @Test
    fun testMonthlyRecurrence_leapYear() {
        val date = LocalDate.of(2024, 2, 29)
        val next = recurrenceHelper.calculateNextDate(date, RecurrenceType.MONTHLY)
        assertEquals(LocalDate.of(2024, 3, 29), next)
    }
    
    @Test
    fun testMonthlyRecurrence_endOfJanToFeb() {
        val date = LocalDate.of(2024, 1, 31)
        val next = recurrenceHelper.calculateNextDate(date, RecurrenceType.MONTHLY)
        assertEquals(LocalDate.of(2024, 2, 29), next)
    }
    
    @Test
    fun testDailyRecurrence() {
        val date = LocalDate.of(2024, 1, 15)
        val next = recurrenceHelper.calculateNextDate(date, RecurrenceType.DAILY)
        assertEquals(LocalDate.of(2024, 1, 16), next)
    }
    
    @Test
    fun testWeeklyRecurrence() {
        val date = LocalDate.of(2024, 1, 15)
        val next = recurrenceHelper.calculateNextDate(date, RecurrenceType.WEEKLY)
        assertEquals(LocalDate.of(2024, 1, 22), next)
    }
    
    @Test
    fun testYearlyRecurrence() {
        val date = LocalDate.of(2024, 1, 15)
        val next = recurrenceHelper.calculateNextDate(date, RecurrenceType.YEARLY)
        assertEquals(LocalDate.of(2025, 1, 15), next)
    }
}
--- FILE: app/src/test/java/com/kharcha/app/BaselinePredictorTest.kt ---

kotlin
package com.kharcha.app

import com.kharcha.app.data.model.TransactionEntity
import com.kharcha.app.data.model.TransactionType
import com.kharcha.app.ml.BaselinePredictor
import org.junit.Assert.assertEquals
import org.junit.Test
import java.time.LocalDateTime
import java.time.YearMonth

class BaselinePredictorTest {
    
    private val predictor = BaselinePredictor()
    
    @Test
    fun testWeightedMovingAverage() {
        val now = LocalDateTime.now()
        val transactions = listOf(
            TransactionEntity(type = TransactionType.EXPENSE, amount = 1000.0, categoryId = 1, date = now.minusMonths(0)),
            TransactionEntity(type = TransactionType.EXPENSE, amount = 900.0, categoryId = 1, date = now.minusMonths(1)),
            TransactionEntity(type = TransactionType.EXPENSE, amount = 800.0, categoryId = 1, date = now.minusMonths(2))
        )
        
        val prediction = predictor.predictNextMonthExpense(transactions)
        
        // Expected: 1000*0.5 + 900*0.3 + 800*0.2 = 500 + 270 + 160 = 930
        assertEquals(930.0, prediction, 1.0)
    }
    
    @Test
    fun testAnomalyDetection() {
        val now = LocalDateTime.now()
        val transactions = listOf(
            TransactionEntity(type = TransactionType.EXPENSE, amount = 100.0, categoryId = 1, date = now),
            TransactionEntity(type = TransactionType.EXPENSE, amount = 110.0, categoryId = 1, date = now),
            TransactionEntity(type = TransactionType.EXPENSE, amount = 105.0, categoryId = 1, date = now),
            TransactionEntity(type = TransactionType.EXPENSE, amount = 1000.0, categoryId = 1, date = now)
        )
        
        val anomalies = predictor.detectAnomalies(transactions)
        assertEquals(1, anomalies.size)
        assertEquals(1000.0, anomalies[0].amount, 0.01)
    }
    
    @Test
    fun testBudgetRecommendation() {
        val now = LocalDateTime.now()
        val transactions = listOf(
            TransactionEntity(type = TransactionType.EXPENSE, amount = 1000.0, categoryId = 1, date = now),
            TransactionEntity(type = TransactionType.EXPENSE, amount = 900.0, categoryId = 1, date = now.minusMonths(1)),
            TransactionEntity(type = TransactionType.EXPENSE, amount = 800.0, categoryId = 1, date = now.minusMonths(2))
        )
        
        val recommendations = predictor.recommendBudget(transactions, 3)
        
        // Expected: (1000 + 900 + 800) / 3 * 1.1 = 900 * 1.1 = 990
        assertEquals(990.0, recommendations[1L] ?: 0.0, 1.0)
    }
}
--- FILE: app/src/test/java/com/kharcha/app/ImportExportTest.kt ---

kotlin
package com.kharcha.app

import org.junit.Test
import java.time.LocalDate
import java.time.format.DateTimeFormatter

class ImportExportTest {
    
    private val dateFormatters = listOf(
        DateTimeFormatter.ISO_LOCAL_DATE,
        DateTimeFormatter.ofPattern("dd/MM/yyyy"),
        DateTimeFormatter.ofPattern("MM/dd/yyyy"),
        DateTimeFormatter.ofPattern("dd-MM-yyyy")
    )
    
    @Test
    fun testDateParsing() {
        val testDates = listOf(
            "2024-01-15",
            "15/01/2024",
            "01/15/2024",
            "15-01-2024"
        )
        
        testDates.forEach { dateString ->
            var parsed = false
            for (formatter in dateFormatters) {
                try {
                    LocalDate.parse(dateString, formatter)
                    parsed = true
                    break
                } catch (e: Exception) {
                    continue
                }
            }
            assert(parsed) { "Failed to parse: $dateString" }
        }
    }
}
--- FILE: app/src/androidTest/java/com/kharcha/app/HomeScreenTest.kt ---

kotlin
package com.kharcha.app

import androidx.compose.ui.test.*
import androidx.compose.ui.test.junit4.createComposeRule
import androidx.navigation.compose.rememberNavController
import androidx.test.ext.junit.runners.AndroidJUnit4
import com.kharcha.app.ui.screens.HomeScreen
import com.kharcha.app.ui.theme.KharchaTheme
import org.junit.Rule
import org.junit.Test
import org.junit.runner.RunWith

@RunWith(AndroidJUnit4::class)
class HomeScreenTest {
    
    @get:Rule
    val composeTestRule = createComposeRule()
    
    @Test
    fun testHomeScreenDisplayed() {
        composeTestRule.setContent {
            KharchaTheme {
                val navController = rememberNavController()
                HomeScreen(navController = navController)
            }
        }
        
        composeTestRule.onNodeWithText("Kharcha").assertIsDisplayed()
    }
}
--- FILE: app/src/main/assets/sample_transactions.csv ---

text
Type,Amount,Currency,Date,Category,Note
EXPENSE,450.50,INR,2024-01-15,Food,Lunch at restaurant
INCOME,5000.00,INR,2024-01-01,Salary,Monthly salary
EXPENSE,200.00,INR,2024-01-10,Transport,Uber rides
--- FILE: app/src/main/assets/sample_sms.txt ---

text
Sample SMS patterns for testing:

1. SBI Bank:
Rs.450.50 debited from A/C XX1234 on 15-Jan-24 at XYZ Store. Avl Bal: Rs.5000.00 -SBI

2. HDFC Bank:
HDFC Bank: Rs 200.00 spent on HDFC Bank Card XX5678 at SWIGGY on 10/01/24. Avl Bal: Rs 4800.00

3. Paytm:
Rs.350.00 credited to your Paytm Wallet. Your balance is Rs.2000.00

4. PhonePe:
You paid Rs.150.00 to Amazon via PhonePe UPI. UPI Ref No: 123456789